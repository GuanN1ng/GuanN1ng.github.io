---
layout: post
title:  "缓存与数据库一致性"
date:   2021-09-08 20:02:47
categories: 系统设计
---

缓存是指基于内存的数据库，通过引入缓存，可以缩短服务响应时间，提升服务吞吐量，并且减轻数据库的IO压力。但**缓存与数据库属于异构数据库，是无法实现强一致性的，缓存系统适用
的场景是非强一致性的场景，属于CAP中的AP，BASE理论**。我们只能尽可能的减少脏数据存在的时间窗口，保证最终一致性。

当数据库内数据发生更新时，采用何种方式更新缓存，需要我们根据⾃⾝的业务场景和对数据⼀致性的容忍程度，综合性地进⾏考量。以下是几种缓存更新的套路。

#### 先更新缓存，再异步更新数据库

这种方式被称为Write Behind Caching Pattern，Write Behind是指更新数据时，只更新缓存，不更新数据库，后期会将有更新的缓存异步的更新到数据库，此时缓存更多的是**缓冲区**的角色。如Linux文件系统的Page Cache算法。

优点：

采用Write Behind的设计可以极大的提升数据的更新速度(基于内存)，且因为更新数据库异步，可以合并对同一个数据的多次操作，极大的提升服务性能。

缺点：

1、数据可能丢失（如Linux非正常关机会导致数据丢失），MySQL Innod更新数据时，也会先使用Change Buffer缓冲，为了保证数据不丢失，额外引入了基于binlog和redo log的2PC事务。

2、实现复杂，需要记录缓存中哪些数据被更新了，需要刷新到数据库内。

#### 先更新数据库，再更新缓存

**缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存**。此方式存在2个问题：

1、线程安全问题
有线程A、B对同一条数据进行更新操作，情况如下，A更新缓存应该比B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。
```
（1）线程A更新DB
（2）线程B更新DB
（3）线程B更新缓存
（4）线程A更新缓存
```

2、业务场景角度
写多读少时，数据尚未被读取，缓存就已被频繁的更新，且如果写入缓存的值需要经过一系列复杂的计算，每次更新都是导致再次计算，这种情况下无疑是浪费性能的。

综上：如果业务非常简单，只是去数据库拿一个值，写入缓存，那么更新缓存也是可以的。但是，**删除缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式**。



#### 先删除缓存，再更新数据库

先删除缓存，再更新数据库，在数据库未更新成功之前，读取数据将会miss cache，故⽽从DB中取数据，此时取出的数据为旧值。DB更新完毕后，那么此时缓存中的数据就是错误数据，并且会⼀直错到缓存过期或者是下⼀次的数据更新。

![先删除缓存，再更新数据库](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%86%8D%E6%9B%B4%E6%96%B0DB.jpg)

#### 先更新数据库，再删除缓存

这种方式被称为Cache Aside Pattern，在绝大多数场景下这种方式都能够保证良好的数据一致性。但是，在某些极端高并发的场景下，Cache Aside Pattern仍然会导致数据不一致的情况。

情况一：
```
（1）缓存刚好失效
（2）线程A查询数据库，得一个旧值
（3）线程B将新值写入数据库
（4）线程B删除缓存
（5）线程A将查到的旧值写入缓存
```

情况二：

![先更新数据库，再删除缓存](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/%E5%85%88%E6%9B%B4%E6%96%B0DB%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98.jpg)

情况三：

数据库读写分离的情况下，主库与从库同步的延时存在，也会造成数据不一致。

实际上，上述情况出现的条件非常苛刻，先更新数据库，再删除缓存的方式已足够应付日常业务场景，且不需要过多设计及开发工作量。

#### 延时双删

为应对Cache Aside Pattern在并发量较高情况下可能会出现的数据不一致问题，为保证删除的有效性，缩短数据不一致的时间窗口，可使用延时双删的方法，即**先更新DB，再删除缓存，隔一段时间后，再进行删除**。

这种方式下，脏数据最多的存活时间为两次删除之间的延时时间，我们可通过MQ或定时任务实现，但由于多删除了一次缓存，即相当于可能会造成DB的查询压力为原来的2倍。

#### 订阅binlog

采用订阅binlog，无需在业务端对Redis进行任何的更新、删除操作，这些操作将由监听binlog变化的线程处理。但需要额外引入Canal、MQ等中间件，增加系统复杂度。



#### 推荐：

[wiki cache词条](https://en.wikipedia.org/wiki/Cache_(computing)/)

[缓存更新的套路——陈皓](https://coolshell.cn/articles/17416.html)

