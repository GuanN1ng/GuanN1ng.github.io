---
layout: post
title:  "JVM内存结构"
date:   2021-05-06 16:52:28
categories: JVM
---

java虚拟机规范定义了若干种程序运行期间会使用到的运行时数据区(Run-Time Data Areas),包括PC计数器, 虚拟机栈, 本地方法栈, 堆, 方法区, 运行时常量池。
该规范指出Java虚拟机, 必须要包含这些区域, 但是这些区域的内存实现，由具体的虚拟机决定。

#### PC计数器

程序计数器是**程序控制流的指示器**，分支、循环、跳转、异常处理及线程恢复等基础功能均依赖程序计数器完成。程序计数器是各**线程私有**的，确保线程切换后能恢复到
正确的执行位置，线程间互不影响，随着线程结束而销毁。

计数器记录的内容是java**字节码指令的地址**，如果是Native方法，记录内容为Undefined。且只存下一个字节码指令的地址，内存占用为固定值，故该区域是**唯一一个**
《Java虚拟机规范》中**没有规定OOM**的区域。

#### Java虚拟机栈

Java虚拟机栈是线程私有的，生命周期与线程相同。描述的是Java方法执行的**线程内存模型**，栈帧是**方法级别**的，当一个方法被执行时，Java虚拟机会同步创建一个栈帧，用于存储局部变量表、
操作数栈、动态连接、方法出口等信息。方法从被执行到执行结束，对应一个栈帧从入栈到出栈的过程。

局部变量表内存放着编译器可知的各种基本数据类型、对象引用、下一条字节码指令的地址`returnAddress`,空间区域单位为Slot。其中HotSpot虚拟机栈中对象引用存储的是
被指向对象的直接指针，而非指向句柄，使得访问对象更快。

《Java虚拟机规范》规定了两种异常：

* StackOverFlowError，线程请求的栈深度大于虚拟机允许的栈深度，即Java虚拟机栈的最大内存占用。

* OOM，HotSpot虚拟机不支持栈的动态扩展，只有当线程创建并申请内存时引起OOM。


#### 本地方法栈

本地方法栈主要为虚拟机使用Native方法服务，**HotSpot虚拟机实现时，将本地方法栈与Java虚拟机栈合二为一**。

#### Java堆

Java Heap在虚拟机启动时创建，用来存放实例对象，由所有线程共享。《Java虚拟机规范》规定Java Heap**可以处于物理上不连续的空间**，但在逻辑上被视为连续，
且大小可扩展（通过-Xmx -Xms设定）。

Java Heap的无用实例对象可有GC进行回收，**不同的GC将Java Heap细分为不同的区域**，如基于分代收集理论的GC。但**《Java虚拟机规范》并未对Java Heap进行划分**。
若果Java Heap内没有足够的内存完成实例分配，且堆也无法再扩展，此时会抛出OOM。

对象在堆上的内存分配方式分为**指针碰撞**与**空闲列表**，采用何种分配方式由堆是否规整(占用连续，碎片少)决定，即有垃圾回收算法决定。当多线程进行内存分配时，
虚拟机默认采用CAS保证操作的原子性，另外一种方式是通过`-XX:+UseTLAB(TheadLocalAllocationBuffer)`,将内存分配的动作按照不同的线程划分在不同的空间进行。

#### 方法区

方法区在虚拟机启动时创建，用来存放被虚拟机加载的类型信息、常量、静态变量、即时编译的代码缓存等数据，由所有线程共享。此区域可选择不实现垃圾收集，但同样会抛出
OOM。


#### 运行时常量池

运行时常量池是方法区的一部分，存放被虚拟机加载的Class文件中的常量池表及直接引用。**运行期间也可将新的常量放入常量池中**，如调用**String类的inter()方法**。 



#### 扩展-直接内存

直接内存不属于JVM运行时数据区，也不是《Java虚拟机规范》中定义的内存区域。但JVM运行期间也会使用直接内存并造成OOM，
如通过NIO类，使用Native方法直接分配堆外内存(`Unsafe::allocateMemory`)，并通过DirectByteBuffer对象作为引用操作，减少Java Heap与Native内存间的数据复制，提高性能。

直接内存的大小受限于服务器的物理内存大小,可通过-XX: MaxDirectMemorySize参数指定，如不指定，默认与Java Heap的最大值(-Xmx)一致。

####HotSpot虚拟机内存结构




