---
layout: post
title:  MySQL COUNT执行
date:   2021-05-23 17:18:47
categories: 
- MySQL
---

#### COUNT(*)

* MyISAM引擎将表的总行数存在磁盘上，执行COUNT(*)且`不加过滤条件`时，会直接返回磁盘上存储的行数，效率很高；
* Innodb引擎执行COUNT(*)时，需要读取每一行，并累加。

因为Innodb支持MVCC，只有读取全部数据行依次判断，才能得到基于当前查询的表的总行数。


COUNT(X)执行效率

执行效率顺序 COUNT(*) ≈ COUNT(1) > COUNT(主键) > COUNT(字段)。后两个执行时，优化器会判断字段是否为null。

Innodb使用数据库保存行数，通过事务隔离确保数据一致，使行数不受其它事务修改记录或插入操作的影响。



#### Order By










#### 幻读

* 幻读是指一个事务在前后两次查询同一个范围时，后一次查询看到了前一次查询没有看到的行。
    * 可重复读的隔离级别下，普通读是快照读，所以幻读只会出现在"当前读"的情况下。
    * 幻读仅指**新插入的行**，被更新的行不能称为幻读。
    
    
幻读问题：

* 破坏SQL语句语义。
    
    SQL语句`select * from t where c = 5 for update`的语义会对所有c=5的行加行锁，此时另一个事务插入一行新数据且c=5,此时SQL语句的语义不在满足。
    
* 数据一致性问题。

    sessionA执行`select * from t where c = 5 for update`加锁语句后，接着执行`update t set d =100 where c = 5`,**事务并未提交**。
    此时另一个事务插入一行新数据且c=5并提交事务，最后sessionA提交事务。此执行序列不对本库产生影响，但**binlog日志内的先后顺序会变成sessionB的语句早于
    sessionA**，此时根据binlog复制的从库数据内容就会产生不一致。



解决方案；

可重复度：

间隙锁,对记录之间的间隙加锁，确保间隙内无法插入新行。间隙锁之间不存在冲突，可以对同一个间隙多次加锁。

next-key lock

间隙锁和行锁合称next-key lock，每个next-key lock都是**前开后闭区间**。

间隙锁的引入解决了可重复读隔离级别下的幻读，但**锁住更大的范围会导致并发度降低**。


读已提交
binlog日志格式设为row,**binlog_format=row**;



####间隙锁加锁范围

可重复读隔离级别下加锁经验总结：

* 加锁的基本单位是next-key lock。
* 查找过程中访问到的对象才会加锁。
* 唯一索引等值查询，加锁时，next-key lock会退化为行锁。
* 普通索引等值查询，向右遍历索引树且不满足等值条件时，next-key lock会退化为间隙锁。
* 唯一索引上的范围查询会访问到不满足条件的第一个值为止。

* 等值查询

* 非唯一索引等值查询

* 主键索引范围查询

* 非唯一索引范围查询

* 


#### MySQL性能


