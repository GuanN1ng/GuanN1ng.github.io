---
layout: post
title:  "JVM内存分配与GC"
date:   2021-05-10 11:31:47
categories: JVM
---

#### 对象存活分析

一个对象是够还存活，即判断改对象是否还可使用，引用是否有效，有两种经典的算法思想：引用计数算法和可达性分析算法。

##### 引用计数算法

引用计数算法简单来说是指每个对象中保有一个引用计数器，每当有一个地方引用它时，计数器值加1，引用失效时，减1。虽有原理简单、判定也更高效，但有很多
额外情况需要考虑，如对象间的相互循环引用。

##### 可达性分析算法

通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链"Reference Chain"，如果某个
对象到GC Roots间没有任何引用链相连，则证明该对象不再被使用。

###### Java中的GC Roots包含：

* 虚拟机栈中引用的对象。
* 本地方法栈中引用的对象。
* 方法区内类静态属性引用的对象。如Java类中的引用类型静态变量。
* 被同步锁持有的对象。
* 反映JVM内部情况的对象。
* 采用分代收集或局部收集时，会出现被堆中其他部分引用的对象的情况，要考虑关联区域的对象。 

###### HotSpot 可达性分析算法实现

* GC区域内的GC Roots

    * 保证GC Roots枚举的准确性，枚举根节点期间必须**暂停所有用户线程**，防止用户线程改变引用关系。
    * 枚举GC Roots时避免扫描全部的栈及全局性引用，使用**OopMap**存放GC Roots。
    
    对于运行中的用户线程，只有用户线程执行到"**安全点**"才能够记录OopMap,并挂起来等待GC。
    
    安全点(Safe Point)的位置选取：
    * 方法调用、循环跳转、异常跳转等具有"长时间执行特征"的指令序列。
    * 对象创建及其它需要分配堆内存的地方。
    
    用户线程的挂起采用主动中断的模式。线程执行过程中，轮询中断标志位，标志位为真时，线程主动挂起，标志位的位置与安全点的位置一致。
    
    对于非运行中的线程，如线程状态为Blocked或Sleep状态，此时的线程会声明处于"**安全区**"内，引用关系不会再改变。GC时，不会去管理这些线程，当线程要离开
    安全区内时，必须等待GC完成。

* 关联区域的GC Roots
    * 记忆集
    
    **分代收集或局部收集**的关联引用部分的GC Roots采用**记忆集**实现，记忆集是一种由非收集区域指向收集区域的指针集合ADT，HotSpot采用字节数组的"卡表"
    实现，卡表中的每一个元素都对应一块特定大小的的内存块，这个内存块称为"卡页"，HotSpot中每个卡页大小为2的9次幂，512字节。只要一个卡页内有一个对象存在跨区域
    引用，则将该区域对应卡表的值标识为1，称这个元素变脏(Dirty)。GC时，只需将卡表内的Dirty Element指向的卡页内存块内的对象加入GC Roots。
    
    * 卡页修改
    
    引用对象赋值时会产生一个Around通知，虚拟机通过AOP操作卡表。
    

###### Java中的引用：

* 强引用
永远不会回收强引用的对象。

* 软引用
当系统将要发生OOM时，会先将软引用对象进行回收，若还是没有足够的内存，才会抛出OOM。

* 弱引用
弱引用的对象只能存活到下一次GC前。

* 虚引用

#### GC算法

* 标记-清除算法

算法先执行**对象标记**，然后再执行**清除对象**。缺点：1、标记和清除过程的执行效率随着对象数量增长而降低；2、会产生大量的内存碎片。

* 标记-复制算法

将可用内存分为大小相等的两块，**每次只使用其中一块**，GC发生时，将存活对象复制到另一块区域，然后对已使用的空间一次性清理。适用于存活对象只占少数的情况，
且分配内存时无需考虑碎片。缺点是内存利用率低，可用内存只有一半空间。

* 标记-整理算法

标记阶段与标记-清除算法一致，而后将存活对象向内存空间的一端移动，再将边界以外的内存空间清理。优点：避免内存空间碎片化。缺点：移动对象时必须暂停用户线程
"Stop The World"。

#### 垃圾收集器


##### 分代收集器



###### 分代收集理论

依赖假说：
* 绝大数对象朝生夕灭。
* 熬过越多次GC过程的对象越难已消亡。
* 跨代引用比起同代引用占极少数。