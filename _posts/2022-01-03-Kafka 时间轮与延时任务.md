---
layout: post 
title:  Kafka 时间轮与延时任务 
date:   2022-01-03 18:28:46 
categories: Kafka
---

# TimingWheel

Kafka中存在大量的延时操作，比如延时生产、延时拉取和延时删除等。Kafka并没有使用JDK自带的Timer或DelayQueue来实现延时的功能，而是基于时间轮的概念自定义实现了一个
用千延时功能的定时器(SystemTimer)。JDK中Timer和DelayQueue(二者的任务存储均使用数组实现的基于平衡二叉树的优先级队列)的插入和删除操作的平均时间复杂度为O(logn)并不能满足Kafka的高性能要求，
而基于时间轮可以将插入和删除操作的时间复杂度都降为0(1)。


TimingWheel类定义如下：

```
private[timer] class TimingWheel(tickMs: Long,  //时间轮时间格跨度  
                                 wheelSize: Int,  //时间轮时间格数，即单层时间轮buckets数量，固定20
                                 startMs: Long,  // 时间轮对象被创建时的起始时间戳
                                 taskCounter: AtomicInteger, //本层时间轮上的总定时任务数
                                 queue: DelayQueue[TimerTaskList] //将所有 Bucket 按照过期时间排序的延迟队列
                                 ) {
  //时间轮的总时间跨度
  private[this] val interval = tickMs * wheelSize 
  //时间轮数组，
  private[this] val buckets = Array.tabulate[TimerTaskList](wheelSize) { _ => new TimerTaskList(taskCounter) }
  //当前时间轮所处的时间。
  private[this] var currentTime = startMs - (startMs % tickMs) // rounding down to multiple of tickMs

  // volatile JVM可见性
  //上层时间轮
  @volatile private[this] var overflowWheel: TimingWheel = null
  
  ... //other code
}
```

TimingWheel使用**数组实现一个环形列表，即buckets**，长度为20，


![TimingWheel](https://raw.githubusercontent.com/GuanN1ng/diagrams/main/com.guann1n9.diagrams/kakfa/Kafka%20TimeWheel.png){:height="80%" width="80%"}



数组的元素类型为TimerTaskList







