---
layout: post
title:  SQL语句
date:   2023-09-25 14:05:53
categories: SQL
---

SQL（结构化查询语言）是操作关系数据库的标准语言，是一种面向集合的编程语言，它操作的对象是集合，操作的结果也是集合。

# 关系模型

关系型数据库是指采用了关系模型来组织数据的数据，而关系模型由数据结构、关系操作、完整性约束三部分组成：

* 数据结构是指关系表，包括基础表、派生表（查询结果）和虚拟表（视图）。
* 关系操作使用的就是SQL语言，常用的关系操作包括增加、删除、修改和查询（CRUD）。其中查询操作最为复杂，包括选择（Selection）、投影（Projection）、并集（Union）、交集（Intersection）、差集（Exception）以及笛卡儿积（Cartesian product）等等。
* 完整性约束用于维护数据的完整性或者满足业务约束的需求，包括实体完整性（主键约束）、参照完整性（外键约束）以及用户定义的完整性（非空约束、唯一约束、检查约束和默认值）。


# 逻辑顺序


![SQL 逻辑顺序](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/sql_order.png)

* FROM：从不同数据表中获取数据；
* ON：对FROM从**驱动表**中拿出一条记录进行ON条件的判断，若符合，再到**被驱动表**中根据ON条件进行扫描匹配；
* JOIN：根据不同的JOIN类型生成JOIN集合（多表JOIN，以第一个JOIN的结果作为驱动表重复FROM-ON-JOIN过程）；
* WHERE：基于WHERE条件对集合内的每一行进行判断，保留条件为ture的；
* GROUP BY：对上一步过滤过后记录集合使用分组key进行分组；
* HAVING：过滤不符合条件的分组：
  * HAVING必须与GROUP BY搭配使用（MySQL对单独使用HAVING会做重写，自动添加GROUP BY NULL，GROUP BY NULL等价于LIMIT 1）;
  * HAVING后的条件不可使用SELECT条件后的别名（MySQL 5.7.5或之后的版本ONLY_FULL_GROUP_BY sql mode默认开启，对标准SQL进行了扩展，允许在HAVING condition中使用SELECT list中的alias）；
* SELECT：对SELECT后的表达式进行运算，得到结果集；
* UNION：将多个SELECT后的结果集按合并规则（UNION/UNION ALL）合并；
* ORDER BY：对结果集按排序key进行排序；
* LIMIT：从全量结果集中取出指定行的记录并返回；

# SELECT运算模型


## 逐行运算

逐行运算是指SELECT后的**每个表达式对数据集的每一行做映射计算**，计算结果的行数与输入数据集的行数相同，且**表达式计算时，只能看到当前行的数据**。逐行运算模式下可使用的表达式主要包括：
* 表字段
* 常量或常量表达式
* 算术表达式
* 布尔表达式
* 单行函数，诸如日期类、字符串类、数学运算类等等

```sql
SELECT
	id,       #表字段
	id+1,      #算数表达式
	id > 2,    #布尔表达式
	GREATEST( value_a, value_b )  #单行函数
FROM
	table_A
```


## 分组聚合运算

分组聚合运算是指SELECT后的**每个表达式对每个分组集做映射计算**，计算结果的行数与分组数一致，**表达式计算时，可看见当前整个组的数据**。分组聚合运算模式下可使用的表达式主要包括：
* 分组key字段
* 常量或包含分组key字段表达式
* 聚合函数

```sql
SELECT
	key,      #表字段
	key + 1,  #仅使用分组key和常量的表达式
	1+1,      #常量表达式
	GREATEST( MAX(value_a), MAX(value_b) )  #基于聚合函数的单行函数
FROM
	table_A
GROUP BY
    key
```

## 窗口运算

窗口运算是指先将数据集按指定的规则分为若干个窗口，并使用相应的窗口函数进行计算，窗口运算的格式如下：
```sql

<窗口函数> over (partition by <用于分组的列名>  order by <用于排序的列名>  [rows between/range between <窗口计算边界>])

```
可理解为先执行**partition by**关键字将数据集划分为多个窗口，分组列可多个，再执行**order by**关键字对窗口内的数据进行排序，然后使用**rows between**或**range between**进行**窗口级别的范围选择**，
得到窗口函数计算时映射的数据集，最后使用窗口函数进行计算得到结果。


### 窗口函数

常用的窗口函数有三类：排序函数、聚合函数以及跨行取数函数。

#### 排序函数

常用排序函数有三种：
* row_number()，为窗口内的每条数据按顺序生成**从1开始的自然增长**的行号，**行号不会重复**；
* rank()，**按照排序字段的值为窗口内的每条数据生成排名**，若排序值相同则记录的排名也相同，后续生成的排名则跳跃至已排名记录的个数的值；
* dense_rank()，**密集排名**，若排序值相同记录的排名相同，**后续排名继续+1自增**。

示例如下：

```sql
# 按照`id`进行分区并按照`amount`进行排序，row_number()、rank()、dense_rank()进行排序打标。
SELECT
	id,
	amount,
	row_number() over ( PARTITION BY id ORDER BY amount ) rowNumber,
	rank() over ( PARTITION BY id ORDER BY amount ) rankNumber,
	dense_rank() over ( PARTITION BY id ORDER BY amount ) denseRankNumber 
FROM
	day_amount;
	
	
+----------+---------+------------+-------------+------------------+
| id       | amount  | rownumber  | ranknumber  | denseRanknumber  |
+----------+---------+------------+-------------+------------------+
| 1        | 5       | 1          | 1           | 1                |
| 1        | 10      | 2          | 2           | 2                |
| 1        | 20      | 3          | 3           | 3                |
| 1        | 20      | 4          | 3           | 3                |
| 1        | 24      | 5          | 5           | 4                |
| 1        | 30      | 6          | 6           | 5                |
| 1        | 30      | 7          | 6           | 5                |
| 1        | 30      | 8          | 6           | 5                |
| 1        | 40      | 9          | 9           | 6                |
| 1        | 40      | 10         | 9           | 6                |
| 2        | 10      | 1          | 1           | 1                |
| 2        | 10      | 2          | 1           | 1                |
| 2        | 10      | 3          | 1           | 1                |
| 2        | 20      | 4          | 4           | 2                |
| 2        | 20      | 5          | 4           | 2                |
| 2        | 20      | 6          | 4           | 2                |
| 2        | 30      | 7          | 7           | 3                |
| 2        | 30      | 8          | 7           | 3                |
| 2        | 30      | 9          | 7           | 3                |
| 2        | 60      | 10         | 10          | 4                |
+----------+---------+------------+-------------+------------------+

```

#### 聚合函数
  * avg(column)，求平均
  * sum(column)，求和
  * count()，统计个数
  * ...


#### 跨行取数函数

跨行取数函数的作用在于可任意获取函数所在窗口内任意一行某个字段的值，如在**计算同比或环比指标时使用**跨行函数则会非常方便。 跨行取数函数使用时，
发生操作的行为当前行（current row）,常用的有以下四种：

* FIRST_VALUE(column)，在一次查询中取出当前窗口内第一行的某一字段的值；
* LAST_VALUE(column)，在一次查询中取出当前窗口内最后一行的某一字段的值；
* LAG(column,N,defaultValue)，在一次查询中取出从当前行之前N行的某一字段的值；
* LEAD(column,N,defaultValue)，在一次查询中取出从当前行之后N行的某一字段的值。

sql示例如下：
```sql
#假设有如下店铺月销售额表，求该店铺23年1月、2月及三月的同比、环比，其中与上年度数据对比称"同比"，与上月数据对比称"环比"
# 同比增长率计算公式：(当年值-上年值)/上年值x100%
# 环比增长率计算公式：(当月值-上月值)/上月值x100%
+----------------------+--------------------+---------------------+
|shop_id               | month              | amount              |
+----------------------+--------------------+---------------------+
| 1                    | 2022-01            | 150                 |
| 1                    | 2022-02            | 200                 |
| 1                    | 2022-03            | 180                 |
| 1                    | 2023-01            | 200                 |
| 1                    | 2023-02            | 300                 |
| 1                    | 2023-03            | 260                 |
+----------------------+--------------------+---------------------+

# 统计sql如下：
SELECT
	shop_id,
	`month`,
	amount,
	last_month_amount,
	last_year_month_amount,
	#计算环比,round保留2位小数
	round((amount / last_month_amount - 1)*100,2) AS month_on_month_ratio,
	#计算同比
	round((amount / last_year_month_amount - 1)*100,2) AS year_on_year_ratio 
FROM
	(
	SELECT
		shop_id,
		`month`,
		amount,
		#获取上月的金额（若没有上月的记录，则使用当前行的值）
		lag( amount, 1, amount ) over ( PARTITION BY shop_id ORDER BY `month` ) AS last_month_amount,
		#获取上一年同月份的金额（此处原表数据只有1月~3月的数据）
		lag( amount, 3, amount ) over ( PARTITION BY shop_id ORDER BY `month` ) AS last_year_month_amount 
	FROM
	shop_sale_m 
	) t1;
	
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
| shop_id  |  month   | amount  | last_month_amount  | last_year_month_amount  | month_on_month_ratio  | year_on_year_ratio  |
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
| 1        | 2022-01  | 150     | 150                | 150                     | 0.0                   | 0.0                 |
| 1        | 2022-02  | 200     | 150                | 200                     | 33.33                 | 0.0                 |
| 1        | 2022-03  | 180     | 200                | 180                     | -10.0                 | 0.0                 |
| 1        | 2023-01  | 200     | 180                | 150                     | 11.11                 | 33.33               |
| 1        | 2023-02  | 300     | 200                | 200                     | 50.0                  | 50.0                |
| 1        | 2023-03  | 260     | 300                | 180                     | -13.33                | 44.44               |
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
```


### 窗口控制



使用rows between可以根据自己的需求任意的控制窗口函数的范围

UNBOUNDED ：不受控的，无限的；
PRECEDING ： 在…之前；
FOLLOWING： 在…之后；

rows between …… and ……

unbounded preceding 前面所有行
unbounded following 后面所有行
current row 当前行
n following  后面n行
n preceding  前面n行




range between 按照列值限制窗口大小（在非条件表达式中等同于rows）
rows表示 行，就是前n行，后n行

而range表示的是 具体的值，比这个值小n的行，比这个值大n的行

range between是以当前值为锚点进行计算

比如

range between 4 preceding AND 7 following

表示：如果当前值为10的话就取前后的值在6到17之间的数据。






# 关联运算



# 过滤运算


where
* 执行顺序在select之前
* 表达式为布尔表达式（包含基于子查询的表达式 IN、 NOT IN、EXIST、 NOT EXIST）
* 逐行过滤（逐行运算模式,无法使用聚合函数）

having
* 执行顺序在最后
* 表达式为布尔表达式
* 分组过滤（对一组数据进行判断，可使用聚合函数）


连续发生模型：

* 过滤出符合条件的记录 ，并按业务维度分区及记录序号排序打行号
* 计算 记录序号 - 行号 的值，得到的差值会有规律：  因行号是连续的，如果记录序号连续， 则差值保持恒定
* 按差值分组统计，获取 满足连续发生条件的 记录