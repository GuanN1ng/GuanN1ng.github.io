---
layout: post 
title:  Kafka 分区状态机与副本状态机
date:   2021-11-06 22:17:56 
categories: Kafka
---

[Kafka Topic生命周期](https://guann1ng.github.io/kafka/2021/10/21/Kafka-Topic%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/) 的源码分析中，无论是Topic的创建、扩容还是删除均是通过
PartitionStateMachine与ReplicaStateMachine完成分区与副本状态的流转。本篇内容将对PartitionStateMachine与ReplicaStateMachine的源码进行分析。

**Broker成功当选为集群Controller后**，会先调用initializeControllerContext()方法，从ZK中读取当前集群中所有的Topic信息，包括Topic的分区和副本信息，然后进行分区与副本的状态初始化，分为两步：

* replicaStateMachine.startup()，启动副本状态机，初始化所有副本状态；
* partitionStateMachine.startup()，启动分区状态机，初始化所有分区状态；

```
private def onControllerFailover(): Unit = {
  ...//other code
  //读取ZK中节点信息 
  initializeControllerContext()

  // We need to send UpdateMetadataRequest after the controller context is initialized and before the state machines
  // are started. The is because brokers need to receive the list of live brokers from UpdateMetadataRequest before
  // they can process the LeaderAndIsrRequests that are generated by replicaStateMachine.startup() and
  // partitionStateMachine.startup().
  sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq, Set.empty)
  //启动副本状态机
  replicaStateMachine.startup()
  //启动分区状态机
  partitionStateMachine.startup()
  
  ...//otherCode

}
```


# ReplicaStateMachine

ReplicaStateMachine负责处理Kafka集群中所有副本的状态流转，并定义了Replica可能处于的7种状态，详情如下：

* **NewReplica**：新建Replica的初始状态，此状态的Replica仅可作为分区的follower副本，有效前置状态(上一个状态)是NonExistentReplica；

* **OnlineReplica**：对应的Partition状态为OnlinePartition后，副本状态从NewReplica流转为OnlineReplica，此状态的Replica即可作为Leader也可作为follower,有效前置状态包括NewReplica，OnlineReplica，OfflineReplica和ReplicaDeletionIneligible；

* **OfflineReplica**：副本离线状态，如持有副本的Broker宕机或收到StopReplicaRequest(deletion=false)。有效前置状态包括NewReplica，OnlineReplica，OfflineReplica和ReplicaDeletionIneligible；

* **ReplicaDeletionStarted**：副本收到StopReplicaRequest(deletion=true)请求，开始执行副本删除时的状态，有效前置状态为OfflineReplica；

* **ReplicaDeletionSuccessful**：副本删除成功(StopReplicaResponse.error=null)后的状态，有效前置状态为ReplicaDeletionStarted；

* **ReplicaDeletionIneligible**：副本删除失败(StopReplicaResponse.error!=null)后的状态，有效前置状态为OfflineReplica和ReplicaDeletionStarted；

* **NonExistentReplica**：副本成功删除的最后状态，有效前置状态为ReplicaDeletionSuccessful；

## startup

ReplicaStateMachine#startup()方法源码如下：

```
//Invoked on successful controller election.
def startup(): Unit = {
  //初始化副本状态
  initializeReplicaState()
  //副本分类  在线副本 离线副本
  val (onlineReplicas, offlineReplicas) = controllerContext.onlineAndOfflineReplicas
  //进行状态变更
  handleStateChanges(onlineReplicas.toSeq, OnlineReplica)
  handleStateChanges(offlineReplicas.toSeq, OfflineReplica)
}
```

Broker当选为Controller后，ReplicaStateMachine需要完成的工作可分为两步：

* 初始化所有副本的状态；
* 将副本分类为onlineReplicas和offlineReplicas，调用handleStateChanges()方法执行相应的状态转换。

### initializeReplicaState

initializeReplicaState()方法源码如下：

```
private def initializeReplicaState(): Unit = {
  controllerContext.allPartitions.foreach { partition =>
    val replicas = controllerContext.partitionReplicaAssignment(partition)
    replicas.foreach { replicaId =>
      //遍历所有的分区副本
      val partitionAndReplica = PartitionAndReplica(partition, replicaId)
      if (controllerContext.isReplicaOnline(replicaId, partition)) {
        //副本在线的状态设置为OnlineReplica
        controllerContext.putReplicaState(partitionAndReplica, OnlineReplica)
      } else {
        // mark replicas on dead brokers as failed for topic deletion, if they belong to a topic to be deleted.
        // This is required during controller failover since during controller failover a broker can go down,
        // so the replicas on that broker should be moved to ReplicaDeletionIneligible to be on the safer side.
        //否则设置为ReplicaDeletionIneligible
        controllerContext.putReplicaState(partitionAndReplica, ReplicaDeletionIneligible)
      }
    }
  }
}

//副本是否在线判断
def isReplicaOnline(brokerId: Int, topicPartition: TopicPartition, includeShuttingDownBrokers: Boolean = false): Boolean = {
  val brokerOnline = {
    if (includeShuttingDownBrokers) liveOrShuttingDownBrokerIds.contains(brokerId)
    else liveBrokerIds.contains(brokerId)
  }
  //broker节点在线 且 分区日志未离线（对应的日志目录未脱机）
  brokerOnline && !replicasOnOfflineDirs.getOrElse(brokerId, Set.empty).contains(topicPartition)
}
```

initializeReplicaState()方法中，会为所有的Replica设置初始状态(更新ControllerContext缓存)，此时仅存在两种状态：若副本在线则将状态设置为OnlineReplica，否则设置为ReplicaDeletionIneligible。

## 副本状态变更




# PartitionStateMachine

PartitionStateMachine对象负责处理Kafka集群中所有主题分区状态的转换，并定义了Partition可能处于的所有状态。分区状态共有4种：

* **NonExistentPartition**：Partition之前未被创建或者创建后又被删除了，此状态的有效前置状态是OfflinePartition；
* **NewPartition**：Partition创建后的初始状态，此状态下的Partition还没有Leader副本和ISR信息，有效前置状态是NonExistentPartition；
* **OnlinePartition**：完成Partition的Leader副本选举及ISR信息后，分区状态将流转为OnlinePartition，有效前置状态是NewPartition、OnlinePartition或OfflinePartition；
* **OfflinePartition**：当Partition的Leader副本副本掉线或删除分区Topic时，分区状态将流转为OfflinePartition，有效前置状态是NewPartition、OnlinePartition或OfflinePartition。


## startup

PartitionStateMachine#startup()方法源码如下：

```
// Invoked on successful controller election.
def startup(): Unit = {
  //初始化分区状态
  initializePartitionState()
  //副本leader选举
  triggerOnlinePartitionStateChange()
}
```

Broker当选为Controller后，PartitionStateMachine需要完成的工作分为两部分：1、初始化集群内所有分区的状态；2、触发OfflinePartition，NewPartition分区leader选举。

### initializePartitionState

initializePartitionState()会遍历所有ControllerContext中所有的分区(当选为Controller后从ZK中读取并缓存)，并为其设置状态：

* Partition没有LeaderAndIsr信息，将分区状态设置为NewPartition；
* Partition有LeaderAndIsr信息：
  * Leader副本在线的，分区状态设置为OnlinePartition；
  * Leader副本离线的，分区状态设置为OfflinePartition；

```
private def initializePartitionState(): Unit = {
  for (topicPartition <- controllerContext.allPartitions) {
    // check if leader and isr path exists for partition. If not, then it is in NEW state
    //检查分区是否存在leader和isr信息
    controllerContext.partitionLeadershipInfo(topicPartition) match {
      case Some(currentLeaderIsrAndEpoch) =>
        // check if the leader for partition is alive. If yes, it is in Online state, else it is in Offline state
        if (controllerContext.isReplicaOnline(currentLeaderIsrAndEpoch.leaderAndIsr.leader, topicPartition))
        // leader is alive
          controllerContext.putPartitionState(topicPartition, OnlinePartition)
        else
          controllerContext.putPartitionState(topicPartition, OfflinePartition)
      case None =>
        controllerContext.putPartitionState(topicPartition, NewPartition)
    }
  }
}
```

### triggerOnlinePartitionStateChange

完成分区状态初始化后，调用triggerOnlinePartitionStateChange()方法为所有状态为OfflinePartition或NewPartition的触发一次分区副本Leader选举，若选举成功，则将分区状态更新为
OnlinePartition。选举策略为OfflinePartitionLeaderElectionStrategy。源码如下：

```
def triggerOnlinePartitionStateChange(): Map[TopicPartition, Either[Throwable, LeaderAndIsr]] = {
  //获取所有OfflinePartition, NewPartition状态的分区
  val partitions = controllerContext.partitionsInStates(Set(OfflinePartition, NewPartition))
  triggerOnlineStateChangeForPartitions(partitions)
}

private def triggerOnlineStateChangeForPartitions(partitions: collection.Set[TopicPartition]): Map[TopicPartition, Either[Throwable, LeaderAndIsr]] = {
  // try to move all partitions in NewPartition or OfflinePartition state to OnlinePartition state except partitions
  // that belong to topics to be deleted
  val partitionsToTrigger = partitions.filter { partition =>
    //过滤待删除的Topic
    !controllerContext.isTopicQueuedUpForDeletion(partition.topic)
  }.toSeq
  //进行状态变更及使用OfflinePartitionLeaderElectionStrategy策略进行leader选举
  handleStateChanges(partitionsToTrigger, OnlinePartition, Some(OfflinePartitionLeaderElectionStrategy(false)))
}
```

## handleStateChanges

ZkPartitionStateMachine#handleStateChanges()方法是分区状态机的核心方法，负责分区状态流转的实现，且如有需要，使用传入的分区副本Leader选举策略PartitionLeaderElectionStrategy完成Leader选举。源码如下：

```
  override def handleStateChanges(
    partitions: Seq[TopicPartition], //待变更状态的分区
    targetState: PartitionState, // 目标状态
    partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy] //可选参数，副本leader选举策略
  ): Map[TopicPartition, Either[Throwable, LeaderAndIsr]] = {
    if (partitions.nonEmpty) {
      try {
        //创建批量请求
        controllerBrokerRequestBatch.newBatch()
        //执行状态转移及leader选举
        val result = doHandleStateChanges( partitions, targetState, partitionLeaderElectionStrategyOpt)
        //发送分区变更状态时创建爱的相关请求(LeaderAndIsr 请求和 UpdateMetadata)给所有的broker
        controllerBrokerRequestBatch.sendRequestsToBrokers(controllerContext.epoch)
        result
      } catch {
        ...// error
      }
    } else {
      Map.empty
    }
  }
```

执行分区状态变更的是方法doHandleStateChanges()，实现如下：

```
private def doHandleStateChanges(
  partitions: Seq[TopicPartition],
  targetState: PartitionState,
  partitionLeaderElectionStrategyOpt: Option[PartitionLeaderElectionStrategy]
): Map[TopicPartition, Either[Throwable, LeaderAndIsr]] = {
  val stateChangeLog = stateChangeLogger.withControllerEpoch(controllerContext.epoch)
  val traceEnabled = stateChangeLog.isTraceEnabled
  //分区不存在，则初始化为NonExistentPartition状态
  partitions.foreach(partition => controllerContext.putPartitionStateIfNotExists(partition, NonExistentPartition))
  //检查分区当前状态是否为目标状态的有效前置状态
  val (validPartitions, invalidPartitions) = controllerContext.checkValidPartitionStateChange(partitions, targetState)
  invalidPartitions.foreach(partition => logInvalidTransition(partition, targetState))

  targetState match {
    case NewPartition =>
      ...// 
    case OnlinePartition =>
      ...//
    case OfflinePartition | NonExistentPartition =>
      ...//
  }
}
```

doHandleStateChanges()方法中根据不同的目标状态逻辑处理共分为3个分支：分别为：NewPartition，OnlinePartition和OfflinePartition | NonExistentPartition。

### NewPartition

当分区目标状态为NewPartition，有效前置状态是NonExistentPartition，即此时正在创建分区(创建主题或分区扩容)，分区状态机只需完成ControllerContext缓存更新即可。

```
case NewPartition =>
  validPartitions.foreach { partition =>
    stateChangeLog.info(s"Changed partition $partition state from ${partitionState(partition)} to $targetState with assigned replicas ${controllerContext.partitionReplicaAssignment(partition).mkString(",")}")
    controllerContext.putPartitionState(partition, NewPartition)
  }
  Map.empty
```

### OnlinePartition

当分区目标状态为OnlinePartition，此时共分为两种情况：

* 当前分区状态为NewPartition，此时需要为新建分区完成leader及ISR初始化并更新ControllerContext缓存中的副本状态，Leader为所有onlineReplica列表的第一个，ISR为全部onlineReplica。initializeLeaderAndIsrForPartitions()方法的源码分析可见[Kafka Topic生命周期](https://guann1ng.github.io/kafka/2021/10/21/Kafka-Topic%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/) ,此处不再复述。
* 当前分区状态为OfflinePartition或OnlinePartition，通过指定的分区leader副本选举策略(若无抛出异常)进行选举，选举成功后，更新ControllerContext缓存中的副本状态。

上述两种情况，本质均是完成分区Leader副本的选举，选举成功后，都会触发向分区所有Replica发送LeaderAndIsr请求。具体的选举策略见下方。

```
case OnlinePartition =>
  //当前状态为NewPartition的分区
  val uninitializedPartitions = validPartitions.filter(partition => partitionState(partition) == NewPartition)
  //当前状态为OfflinePartition或OnlinePartition的分区
  val partitionsToElectLeader = validPartitions.filter(partition => partitionState(partition) == OfflinePartition || partitionState(partition) == OnlinePartition)
  if (uninitializedPartitions.nonEmpty) {
    //为状态为NewPartition的分区初始化leader 及 ISR信息，初始化成功后更新状态为OnlinePartition
    val successfulInitializations = initializeLeaderAndIsrForPartitions(uninitializedPartitions)
    successfulInitializations.foreach { partition =>
      controllerContext.putPartitionState(partition, OnlinePartition)
    }
  }
  if (partitionsToElectLeader.nonEmpty) {
    //当前状态为OfflinePartition或OnlinePartition的分区，进行leader选举
    val electionResults = electLeaderForPartitions( partitionsToElectLeader,
      //未设置选举策略抛出异常
      partitionLeaderElectionStrategyOpt.getOrElse( throw new IllegalArgumentException("Election strategy is a required field when the target state is OnlinePartition"))
    )

    electionResults.foreach {
      case (partition, Right(leaderAndIsr)) =>
        stateChangeLog.info(
          s"Changed partition $partition from ${partitionState(partition)} to $targetState with state $leaderAndIsr"
        )
        //选举成功，更新状态为OnlinePartition
        controllerContext.putPartitionState(partition, OnlinePartition)
      case (_, Left(_)) => // Ignore; no need to update partition state on election error
    }

    electionResults
  } else {
    Map.empty
  }
```


### OfflinePartition | NonExistentPartition

当分区目标状态为OfflinePartition或NonExistentPartition，分区状态机只需完成ControllerContext缓存更新即可。

```
case OfflinePartition | NonExistentPartition =>
  validPartitions.foreach { partition =>
    if (traceEnabled) stateChangeLog.trace(s"Changed partition $partition state from ${partitionState(partition)} to $targetState")
    controllerContext.putPartitionState(partition, targetState)
  }
  Map.empty
```


## 分区Leader副本选举算法

