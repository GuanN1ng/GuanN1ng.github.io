---
layout: post
title:  "JVM内存回收"
date:   2021-05-10 11:31:47
categories: JVM
---

#### 对象存活分析

一个对象是够还存活，即判断改对象是否还可使用，引用是否有效，有两种经典的算法思想：引用计数算法和可达性分析算法。

##### 引用计数算法

引用计数算法简单来说是指每个对象中保有一个引用计数器，每当有一个地方引用它时，计数器值加1，引用失效时，减1。虽有原理简单、判定也更高效，但有很多
额外情况需要考虑，如对象间的相互循环引用。

##### 可达性分析算法

通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链"Reference Chain"，如果某个
对象到GC Roots间没有任何引用链相连，则证明该对象不再被使用。

###### Java中的GC Roots包含：

* 虚拟机栈中引用的对象。
* 本地方法栈中引用的对象。
* 方法区内类静态属性引用的对象。如Java类中的引用类型静态变量。
* 被同步锁持有的对象。
* 反映JVM内部情况的对象。
* 采用分代收集或局部收集时，会出现被堆中其他部分引用的对象的情况，要考虑关联区域的对象。 

###### HotSpot 可达性分析算法实现

* GC区域内的GC Roots

    * 保证GC Roots枚举的准确性，枚举根节点期间必须**暂停所有用户线程**，防止用户线程改变引用关系。
    * 枚举GC Roots时避免扫描全部的栈及全局性引用，使用**OopMap**存放GC Roots。
    
    对于运行中的用户线程，只有用户线程执行到"**安全点**"才能够记录OopMap,并挂起来等待GC。
    
    安全点(Safe Point)的位置选取：
    * 方法调用、循环跳转、异常跳转等具有"长时间执行特征"的指令序列。
    * 对象创建及其它需要分配堆内存的地方。
    
    用户线程的挂起采用主动中断的模式。线程执行过程中，轮询中断标志位，标志位为真时，线程主动挂起，标志位的位置与安全点的位置一致。
    
    对于非运行中的线程，如线程状态为Blocked或Sleep状态，此时的线程会声明处于"**安全区**"内，引用关系不会再改变。GC时，不会去管理这些线程，当线程要离开
    安全区内时，必须等待GC完成。

* 关联区域的GC Roots
    * 记忆集
    
    **分代收集或局部收集**的关联引用部分的GC Roots采用**记忆集**(Remember Set)实现，记忆集是一种由非收集区域指向收集区域的指针集合ADT，HotSpot采用字节数组的"卡表"
    实现，卡表中的每一个元素都对应一块特定大小的的内存块，这个内存块称为"卡页"，HotSpot中每个卡页大小为2的9次幂，512字节。只要一个卡页内有一个对象存在跨区域
    引用，则将该区域对应卡表的值标识为1，称这个元素变脏(Dirty)。GC时，只需将卡表内的Dirty Element指向的卡页内存块内的对象加入GC Roots。
    
    * 卡页修改实现
    
    **写屏障**：引用对象赋值时会产生一个Around通知，虚拟机通过AOP操作卡表。
    
    
* 三色标记算法
    
    为了降低用户线程的停顿，引入了并发标记，并发标记一般由三色标记算法实现，在并发标记阶段，把遍历对象图过程中遇到的对象，按照"是否访问过"标记为三种颜色：
    
    * 白色：表示对象尚未被垃圾回收器访问过。GC刚开启阶段，所有对象都是白色的，若**在GC结束时，对象仍然是白色的，即代表不可达**。
    
    * 黑色：表示对象已被GC扫描过，且该对象的所有引用也都已扫描过。**黑色对象代表存活对象**，如果其他对象的引用指向黑色对象，无需重新扫描。**黑色对象
        不能直接指向(不经过灰色对象)白色对象**。 
    
    * 灰色：表示对象已被GC扫描过，但这个对象上仍至少存在一个引用(对象中指向其他对象的引用)未被扫描过。
    
    并发标记阶段，用户线程对象引用的修改可能会造成**对象消失**，即原本黑色的对象被误标记为白色，当下两种情况同时出现时会引发该问题：
    * 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
    * 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；
    
    解决方案：**增量更新和原始快照**：
    
    增量更新破坏第一个条件：当黑色对象新插入了指向白色对象的引用，将其标记为灰色（将新引用记录下来），再次进行扫描；
    
    原始快照破坏第二个条件：对灰色对象删除指向白色对象的引用时，将删除的引用记录下来，并发扫描结束后，再以记录中的对象为根扫描。即始终以扫描刚开的哪一个的对象图
    进行搜索。

###### Java中的引用：

* 强引用
永远不会回收强引用的对象。

* 软引用
当系统将要发生OOM时，会先将软引用对象进行回收，若还是没有足够的内存，才会抛出OOM。

* 弱引用
弱引用的对象只能存活到下一次GC前。

* 虚引用

#### GC算法

* 标记-清除算法

算法先执行**对象标记**，然后再执行**清除对象**。缺点：1、标记和清除过程的执行效率随着对象数量增长而降低；2、会产生大量的内存碎片。

* 标记-复制算法

将可用内存分为大小相等的两块，**每次只使用其中一块**，GC发生时，将存活对象复制到另一块区域，然后对已使用的空间一次性清理。适用于存活对象只占少数的情况，
且分配内存时无需考虑碎片。缺点是内存利用率低，可用内存只有一半空间。

* 标记-整理算法

标记阶段与标记-清除算法一致，而后将存活对象向内存空间的一端移动，再将边界以外的内存空间清理。优点：避免内存空间碎片化。缺点：移动对象时必须暂停用户线程
"Stop The World"。

#### 垃圾收集器

##### 分代收集器

分代收集理论，将Java堆划分出不同的区域，根据对象年龄(熬过GC次数)将对象分配到不同的区域存储。垃圾收集器可以每次只回收部分区域，也能够根据不同区域内的
对象选择不同的GC算法。

HotSpot中的分代垃圾收集器将Java堆划分为新生代(Young Generation)和老年代(Old Generation),新生代又被细分为Eden、Survivor From、Survivor To区域。
    
依赖假说：
* 绝大数对象朝生夕灭。
* 熬过越多次GC过程的对象越难已消亡。
* 跨代引用比起同代引用占极少数。


主流GC收集器：

* Serial  

    单线程GC，GC时暂停所有用户线程，直至GC完成。用于新生代，新生代采用标记-复制算法。适用单核服务器环境。
* ParNew  

    Serial收集器的多线程版本。用于新生代，JDK7时官方推荐ParNew和CMS。
* Parallel Scavenge  

    关注吞吐量的GC收集器，可指定MaxGCPauseMillis和GCTimeRatio参数确保GC时间。
* Serial Old

    Serial收集器的老年代版本，采用标记-整理算法。
* Parallel Old

    老年代的收集器，是Parallel Scavenge老年代的版本。
* CMS

    CMS(Concurrent Mark Swap)收集器是一种以获取**最短回收停顿时间**为目标的收集器。基于标记-清除算法实现，用于回收老年代，**JDK9后标注为废弃**。回收过程分为
    四步：
    * 初始标记
        暂停用户线程，标记GC Roots直接关联的对象。
    * 并发标记
        无需暂停用户线程，开始从GC Roots直接关联的对象遍历标记对象图(基于增量更新的三色标记)。
    * 重新标记
        暂停用户线程，修正并发标记阶段用户线程执行时导致标记变动的对象。
    * 并发清除
        已标记完成，无需暂停用户线程，清理死亡对象。
  
* G1

    G1的设计目标是能够支持指定在一个长度为M毫秒的时间片段内，消耗在GC的时间不超过N毫秒，即GC停顿时间不会随着堆大小增加。G1收集器的堆内存基础单位为**Region**，
    虽然仍遵循分代收集理论，存在新生代、老年代，但不再坚持固定大小及固定区域的内存划分，每个Region都可以根据需要
    扮演Eden、Survivor、或老年代空间，这些空间是一系列**Region的动态集合，无需连续**。Region中还有一类Humongous区域，专门用来存储**大小超过Region容量**一般大对象，
    通过参数‐XX:G1HeapRegionSize指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区，Region大小为堆/2048。
    
    跨Region引用对象，G1收集器也是通过使用记忆集避免全堆扫描作为GC Roots扫描，每个Region都维护有自己的记忆集，存储结构是哈希表，key为其他Region的
    内存地址，Value是一个集合，存储**卡表**的索引号。
    
    并发标记阶段，G1通过**原始快照**来修正标记对象。GC时新对象的内存分配，G1为每个Region设计了**两个指针**，通过两个指针将Region中的一部分空间划分出来
    用于回收过程中的对象分配。
    
    GC过程：
    
    * 初始标记
    * 并发标记，**只有此阶段，用户线程不被暂停**（基于原始快照的并发标记）。
    * 最终标记，根据原始快照处理并发标记阶段引用变化的对象。
    * 筛选回收，更新Region的统计数据，评估各个Region的回收价值与成本，根据用户指定的MaxGCPauseMillis(默认200ms)选择需要回收的Region组成回收集(Mixed GC)，
    然后将回收集内的存活对象复制到空的Region中，清理掉旧的Region。
    
    缺点：
    
    * G1标记采用三色算法，会产生浮动垃圾；
    * G1采用整理算法，收集速度跟不上回收速度时，无法避免Full GC的产生，STW时间仍不可忽视。
    * 每个Region都维护有自己的Remember Set记录跨域引用，照成额外的内存消耗。 
    
##### 低延迟垃圾收集器-ZGC

ZGC在JDK11中首次支持，设计目标是一款在**任意堆大小下都可以把GC造成用户线程停顿的时间(STW)限制在10ms内的收集器**。

* Java内存划分

    ZGC堆内存基于**动态Region**实现，且**不分代**，动态是指**动态的创建及销毁，以及动态的区域容量**。可细分为**Small Region**，容量固定为2MB，用于放置小于256KB的对象；
    **Medium Region**，容量固定为32MB，用于放置大于256KB小于4MB的对象；**Large Region**，容量不固定，可动态变化，必须为2MB的整数倍，一个Large Region
    内只会存放一个对象。

* 关键技术实现    
    * Colored Pointer
        64位系统下，指针理论上可访问的内存为2^64B(16EB)，当前操作系统无法用尽64位，ZGC的**染色指针**是指**将GC信息转移到指针上**，共占用4位：
            * Finalizable 标识被指针指向的对象是否只能通过finalize()方法访问； 
            * Remapped 是否进入重分配集；
            * Marked1 三色标记状态；
            * Marked0 三色标记状态；
            
        指针被修改后，避免影响操作系统寻址，ZGC使用**多重映射**(Multi-Mapping)将**多个不同的虚拟空间内存地址映射到同一个物理地址内存上**。该染色指针不同标志位下
        指向的虚拟内存空间都指向同一物理地址。   
        
    * 读屏障
        
        因为染色指针的支持，ZGC可以**通过引用指针的值当前访问对象是否处于重分配集中**(Remapped)，当用户访问位于重新分配集中的对象时，会被读屏障拦截，根据重分配Region维护的转发表记录将访问转发到新复制的对象上，并修改
        改引用的值，将其直接指向新对象，ZGC将此行为称为"自愈"。
        
    * NUMA-Aware
        
        Non-Uniform Memory Access，非同一内存访问架构，为多核处理器的计算机所设计的内存架构，将内存控制器集成到处理器内核中，每个处理器核心都有属于
        自己内存控制器所管理的内存区域，也可通过数据总线访问其它内存控制器管理的内存。ZGC收集器会**优先尝试在请求线程所在处理器的本地内存上分配对象，保证高效的内存访问**。
        
* GC步骤
    
    * 初始阶段
    
    * **并发标记** 标记记录上指针上，更新染色指针上的Mark0、Mark1。
    
    * **并发预备重分配** 统计出需要回收的Region,组成重分配集(Relocation Set)，此处并不是类似G1的筛选，ZGC每次都扫描全堆，此步决定
    Region中的存活对象会被分配到其他Region中。
    
    * **并发重新分配** 将重分配集中存活的对象复制到新的Region中，ZGC会为重分配的Region维护一个**转发表**，记录从就对象到新对象的转向关系。
    
    * **并发重新映射** 修正整个堆中指向重分配集中就对象的引用。虽然通过染色指针和读屏障可以"自愈"，但此步的主要目的是提高效率。且并发重新映射会
    合并到下一次GC时的并发标记阶段完成，节省遍历对象图的开销。

* [ZGC使用案例](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)
    
    
      
     

