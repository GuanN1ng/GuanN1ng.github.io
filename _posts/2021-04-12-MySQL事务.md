---
layout: post
title:  "MySQL事务"
date:   2021-04-12 18:00:55
categories: MySQL
---
#### 事务

数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：

1. 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。
    
当事务被提交给了数据库管理系统`DBMS`，则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

#### MySQL的事务隔离(Innodb)

事务隔离是为了解决多事务同时执行时，造成的脏读`dirty read`、不可重复读`non-repeatable read`、幻读`phantom read`的问题，保证一个事务的执行不应影响其他事务的执行。

MySQL的事务隔离级别包括：

 * 读未提交(read uncommitted)，一个事务还没提交时，它做的变更就能被别的事务看到；
 
 * 读提交(read committed)，一个事务提交之后，它做的变更才会被其他事务看到；
 
 * 可重复读(repeatable read)，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；
 
 * 串行化(serializable)，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

MySQL的默认事务隔离级别为可重复读。
```
mysql> show variables like '%tx_isolation%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
```

#### MySQL事务隔离的实现

##### MVCC多版本并发控制

MVCC是指通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。只在Repeatable Read及Read Committed两个隔离级别下工作，
在Read Uncommitted隔离级别下，直接读取版本的最新记录，对于SERIALIZABLE隔离级别，则是通过加锁互斥来访问数据，因此不需要MVCC。

实现核心：

1.事务版本号

每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。

2.行的隐藏列

Innodb引擎为数据库内的每行数据添加了2个隐藏字段：
* DB_TRX_ID，保存行的事务版本号。

* DB_ROLL_PTR，回滚指针，指向该行上个版本数据undo log，Innodb便是通过这个指针找到之前版本的数据。

MVCC操作的逻辑流程：

* INSERT

为插入的每一行保存当前事务id作为行的事务版本号。

* DELETE

为删除的每一行保存指向undo logo的指针。

* UPDATE

先插入的一行新记录，保存当前事务编号作为行版本号，同时保存undo log指针到原来的行作为行删除标识。

* SELECT

InnoDB只查找行的事务编号小于或等于当前事务的事务编号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。

删除的行删除标识大于当前事务版本号。

3.undo log

Innodb在修改数据库数据记录之前会先在undo log中记录回滚日志，包含改动之前的数据及该事务id，通过事务id和undo log我们可以找到历史版本的数据，
用于支持事务回滚和MVCC获取不同事务id对应的数据来实现事务隔离。当没有事务再需要用到这些回滚日志即没有比该回滚日志更早的视图时，回滚日志会被删除。

应减少使用长事务，避免回滚日志无法被及时清理及浪费锁资源。

4.read view

当一个事务启动时，此时在Innodb引擎中的事务可分为3类，`已提交的`、`已启动未提交`的和`未开始的`。Innodb为每个事务构造了一个数组，用来保存这个事务启动瞬间，
当前启动了但还没提交的所有事务id，即`当前活跃事务id集合`。对于查询时的版本链数据是否看见的判断逻辑：

* 如果被访问版本的DB_TRX_ID属性值小于活跃事务列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。

* 如果被访问版本的DB_TRX_ID属性值大于活跃事务列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。

* 如果被访问版本的DB_TRX_ID属性值在活跃事务列表中最大的事务id和最小事务id之间，那就需要判断一下DB_TRX_ID属性值是不是在活跃事务列表中，
如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

对应数据的快照，被称为一致性读视图`consistent read view`，每个事务都只对自己内部的视图进行更改。可重复读(RR)时，
视图在执行第一个SELECT时生成，后续所有的SELECT复用；读已提交(RC)时，每次SELECT时都会创建新的ReadView。

*更新语句及select for update不使用一致性视图*，更新数据都是先读后写的，只能读当前的值，，称为`当前读`(current read)。



