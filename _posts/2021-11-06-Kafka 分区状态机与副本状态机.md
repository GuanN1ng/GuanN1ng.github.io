---
layout: post 
title:  Kafka 分区状态机与副本状态机
date:   2021-11-06 22:17:56 
categories: Kafka
---

[Kafka Topic生命周期](https://guann1ng.github.io/kafka/2021/10/21/Kafka-Topic%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/) 的源码分析中，无论是Topic的创建、扩容还是删除均是通过
PartitionStateMachine与ReplicaStateMachine完成分区与副本状态的流程。本篇内容将对PartitionStateMachine与ReplicaStateMachine的源码进行分析。

Broker成功当选为集群Controller后，会先调用initializeControllerContext()方法，从ZK中读取当前集群中所有的Topic信息，包括Topic的分区和副本信息，然后进行分区与副本的状态初始化，分为两步：

* replicaStateMachine.startup()，启动副本状态机，初始化所有副本状态；
* partitionStateMachine.startup()，启动分区状态机，初始化所有分区状态；

```
private def onControllerFailover(): Unit = {
  ...//other code
  //读取ZK中节点信息 
  initializeControllerContext()

  // We need to send UpdateMetadataRequest after the controller context is initialized and before the state machines
  // are started. The is because brokers need to receive the list of live brokers from UpdateMetadataRequest before
  // they can process the LeaderAndIsrRequests that are generated by replicaStateMachine.startup() and
  // partitionStateMachine.startup().
  sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq, Set.empty)
  //启动副本状态机
  replicaStateMachine.startup()
  //启动分区状态机
  partitionStateMachine.startup()
  
  ...//otherCode

}
```


# ReplicaStateMachine

ReplicaStateMachine负责处理Kafka集群中所有副本的状态流转，并定义了Replica可能处于的7种状态，详情如下：

* **NewReplica**：新建Replica的初始状态，此状态的Replica仅可作为分区的follower副本，有效前置状态(上一个状态)是NonExistentReplica；

* **OnlineReplica**：对应的Partition状态为OnlinePartition后，副本状态从NewReplica流转为OnlineReplica，此状态的Replica即可作为Leader也可作为follower,有效前置状态包括NewReplica，OnlineReplica，OfflineReplica和ReplicaDeletionIneligible；

* **OfflineReplica**：副本离线状态，如持有副本的Broker宕机或收到StopReplicaRequest(deletion=false)。有效前置状态包括NewReplica，OnlineReplica，OfflineReplica和ReplicaDeletionIneligible；

* **ReplicaDeletionStarted**：副本收到StopReplicaRequest(deletion=true)请求，开始执行副本删除时的状态，有效前置状态为OfflineReplica；

* **ReplicaDeletionSuccessful**：副本删除成功(StopReplicaResponse.error=null)后的状态，有效前置状态为ReplicaDeletionStarted；

* **ReplicaDeletionIneligible**：副本删除失败(StopReplicaResponse.error!=null)后的状态，有效前置状态为OfflineReplica和ReplicaDeletionStarted；

* **NonExistentReplica**：副本成功删除的最后状态，有效前置状态为ReplicaDeletionSuccessful；

## startup

ReplicaStateMachine#startup()方法源码如下：

```
//Invoked on successful controller election.
def startup(): Unit = {
  //初始化副本状态
  initializeReplicaState()
  //副本分类  在线副本 离线副本
  val (onlineReplicas, offlineReplicas) = controllerContext.onlineAndOfflineReplicas
  //进行状态变更
  handleStateChanges(onlineReplicas.toSeq, OnlineReplica)
  handleStateChanges(offlineReplicas.toSeq, OfflineReplica)
}
```

Broker当选为Controller后，ReplicaStateMachine需要完成的工作可分为两步：

* 初始化所有副本的状态；
* 将副本分类为onlineReplicas和offlineReplicas，并执行相应的状态变更。

### initializeReplicaState

initializeReplicaState()方法源码如下：

```
private def initializeReplicaState(): Unit = {
  controllerContext.allPartitions.foreach { partition =>
    val replicas = controllerContext.partitionReplicaAssignment(partition)
    replicas.foreach { replicaId =>
      //遍历所有的分区副本
      val partitionAndReplica = PartitionAndReplica(partition, replicaId)
      if (controllerContext.isReplicaOnline(replicaId, partition)) {
        //副本在线的状态设置为OnlineReplica
        controllerContext.putReplicaState(partitionAndReplica, OnlineReplica)
      } else {
        // mark replicas on dead brokers as failed for topic deletion, if they belong to a topic to be deleted.
        // This is required during controller failover since during controller failover a broker can go down,
        // so the replicas on that broker should be moved to ReplicaDeletionIneligible to be on the safer side.
        //否则设置为ReplicaDeletionIneligible
        controllerContext.putReplicaState(partitionAndReplica, ReplicaDeletionIneligible)
      }
    }
  }
}

//副本是否在线判断
def isReplicaOnline(brokerId: Int, topicPartition: TopicPartition, includeShuttingDownBrokers: Boolean = false): Boolean = {
  val brokerOnline = {
    if (includeShuttingDownBrokers) liveOrShuttingDownBrokerIds.contains(brokerId)
    else liveBrokerIds.contains(brokerId)
  }
  //broker节点在线 且 分区日志未离线（对应的日志目录未脱机）
  brokerOnline && !replicasOnOfflineDirs.getOrElse(brokerId, Set.empty).contains(topicPartition)
}
```




# PartitionStateMachine

PartitionStateMachine对象负责处理Kafka集群中所有主题分区状态的转换，并定义了Partition可能处于的所有状态。分区状态共有4种：

* **NonExistentPartition**：Partition之前未被创建或者创建后又被删除了，此状态的有效前置状态是OfflinePartition；
* **NewPartition**：Partition创建后的初始状态，此状态下的Partition还没有Leader副本和ISR信息，有效前置状态是NonExistentPartition；
* **OnlinePartition**：完成Partition的Leader副本选举及ISR信息后，分区状态将流转为OnlinePartition，有效前置状态是NewPartition、OnlinePartition或OfflinePartition；
* **OfflinePartition**：当Partition的Leader副本副本掉线或删除分区Topic时，分区状态将流转为OfflinePartition，有效前置状态是NewPartition、OnlinePartition或OfflinePartition。


## startup

PartitionStateMachine#startup()方法源码如下：

```
// Invoked on successful controller election.
def startup(): Unit = {
  //初始化分区状态
  initializePartitionState()
  //副本leader选举
  triggerOnlinePartitionStateChange()
}
```

Broker当选为Controller后，PartitionStateMachine需要完成的工作分为两部分：1、初始化集群内所有分区的状态；2、触发分区leader选举。

### initializePartitionState

initializePartitionState()会遍历所有ControllerContext中所有的分区(当选为Controller后从ZK中读取并缓存)，并为其设置状态：

* Partition没有LeaderAndIsr信息，将分区状态设置为NewPartition；
* Partition有LeaderAndIsr信息：
  * Leader副

```
private def initializePartitionState(): Unit = {
  for (topicPartition <- controllerContext.allPartitions) {
    // check if leader and isr path exists for partition. If not, then it is in NEW state
    //检查分区是否存在leader和isr信息
    controllerContext.partitionLeadershipInfo(topicPartition) match {
      case Some(currentLeaderIsrAndEpoch) =>
        // check if the leader for partition is alive. If yes, it is in Online state, else it is in Offline state
        if (controllerContext.isReplicaOnline(currentLeaderIsrAndEpoch.leaderAndIsr.leader, topicPartition))
        // leader is alive
          controllerContext.putPartitionState(topicPartition, OnlinePartition)
        else
          controllerContext.putPartitionState(topicPartition, OfflinePartition)
      case None =>
        controllerContext.putPartitionState(topicPartition, NewPartition)
    }
  }
}
```

### triggerOnlinePartitionStateChange



