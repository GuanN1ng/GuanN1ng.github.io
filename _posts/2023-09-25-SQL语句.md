---
layout: post
title:  SQL语句
date:   2023-09-25 14:05:53
categories: SQL
---

SQL（结构化查询语言）是操作关系数据库的标准语言，是一种面向集合的编程语言，它操作的对象是集合，操作的结果也是集合。

# 关系模型

关系型数据库是指采用了关系模型来组织数据的数据，而关系模型由数据结构、关系操作、完整性约束三部分组成：

* 数据结构是指关系表，包括基础表、派生表（查询结果）和虚拟表（视图）。
* 关系操作使用的就是SQL语言，常用的关系操作包括增加、删除、修改和查询（CRUD）。其中查询操作最为复杂，包括选择（Selection）、投影（Projection）、并集（Union）、交集（Intersection）、差集（Exception）以及笛卡儿积（Cartesian product）等等。
* 完整性约束用于维护数据的完整性或者满足业务约束的需求，包括实体完整性（主键约束）、参照完整性（外键约束）以及用户定义的完整性（非空约束、唯一约束、检查约束和默认值）。


# 逻辑顺序


![SQL 逻辑顺序](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/sql_order.png)

* FROM：从不同数据表中获取数据；
* ON：对FROM从**驱动表**中拿出一条记录进行ON条件的判断，若符合，再到**被驱动表**中根据ON条件进行扫描匹配；
* JOIN：根据不同的JOIN类型生成JOIN集合（多表JOIN，以第一个JOIN的结果作为驱动表重复FROM-ON-JOIN过程）；
* WHERE：基于WHERE条件对集合内的每一行进行判断，WHERE后的表达式为布尔表达式（包含基于子查询的表达式 IN、 NOT IN、EXIST、 NOT EXIST）,判断后保留条件为ture的；
* GROUP BY：对上一步过滤过后记录集合使用分组key进行分组；
* HAVING：过滤不符合条件的分组：
  * HAVING必须与GROUP BY搭配使用（MySQL对单独使用HAVING会做重写，自动添加GROUP BY NULL，GROUP BY NULL等价于LIMIT 1）;
  * HAVING后的条件不可使用SELECT条件后的别名（MySQL 5.7.5或之后的版本ONLY_FULL_GROUP_BY sql mode默认开启，对标准SQL进行了扩展，允许在HAVING condition中使用SELECT list中的alias）；
* SELECT：对SELECT后的表达式进行运算，得到结果集；
* UNION：将多个SELECT后的结果集按合并规则（UNION/UNION ALL）合并；
* ORDER BY：对结果集按排序key进行排序；
* LIMIT：从全量结果集中取出指定行的记录并返回；

# SELECT运算模型


## 逐行运算

逐行运算是指SELECT后的**每个表达式对数据集的每一行做映射计算**，计算结果的行数与输入数据集的行数相同，且**表达式计算时，只能看到当前行的数据**。逐行运算模式下可使用的表达式主要包括：
* 表字段
* 常量或常量表达式
* 算术表达式
* 布尔表达式
* 单行函数，诸如日期类、字符串类、数学运算类等等

```sql
SELECT
	id,       #表字段
	id+1,      #算数表达式
	id > 2,    #布尔表达式
	GREATEST( value_a, value_b )  #单行函数
FROM
	table_A
```


## 分组聚合运算

分组聚合运算是指SELECT后的**每个表达式对每个分组集做映射计算**，计算结果的行数与分组数一致，**表达式计算时，可看见当前整个组的数据**。分组聚合运算模式下可使用的表达式主要包括：
* 分组key字段
* 常量或包含分组key字段表达式
* 聚合函数

```sql
SELECT
	key,      #表字段
	key + 1,  #仅使用分组key和常量的表达式
	1+1,      #常量表达式
	GREATEST( MAX(value_a), MAX(value_b) )  #基于聚合函数的单行函数
FROM
	table_A
GROUP BY
    key
```

## 窗口（跨行）运算
窗口运算，也可理解为跨行运算，允许计算时，**不仅可以取到当前行的所有值，还可以使用窗口函数取到当前行所属窗口内的任意范围内的数据**，计算时，先将数据集按指定的规则分为若干个窗口，
然后再使用相应的窗口函数进行计算，窗口运算的格式如下：

```sql

<窗口函数> over (partition by <用于分组的列名>  order by <用于排序的列名>  [rows between/range between <窗口计算边界>])

```
可理解为先执行**partition by**关键字将数据集划分为多个窗口，分组列可多个，再执行**order by**关键字对窗口内的数据进行排序，然后使用**rows between**或**range between**进行**窗口级别的范围选择**，
得到窗口函数计算时映射的数据集，最后使用窗口函数进行计算得到结果。


### 窗口函数

常用的窗口函数有三类：排序函数、聚合函数以及跨行取数函数。

#### 排序函数

排序函数常用于**计算TopN问题**，常用排序函数有三种：
* row_number()，为窗口内的每条数据按顺序生成**从1开始的自然增长**的行号，**行号不会重复**；
* rank()，**按照排序字段的值为窗口内的每条数据生成排名**，若排序值相同则记录的排名也相同，后续生成的排名则跳跃至已排名记录的个数的值；
* dense_rank()，**密集排名**，若排序值相同记录的排名相同，**后续排名继续+1自增**。

示例如下：

```sql
# 按照`id`进行分区并按照`amount`进行排序，row_number()、rank()、dense_rank()进行排序打标。
SELECT
	id,
	amount,
	row_number() over ( PARTITION BY id ORDER BY amount ) rowNumber,
	rank() over ( PARTITION BY id ORDER BY amount ) rankNumber,
	dense_rank() over ( PARTITION BY id ORDER BY amount ) denseRankNumber 
FROM
	day_amount;
	
	
+----------+---------+------------+-------------+------------------+
| id       | amount  | rownumber  | ranknumber  | denseRanknumber  |
+----------+---------+------------+-------------+------------------+
| 1        | 5       | 1          | 1           | 1                |
| 1        | 10      | 2          | 2           | 2                |
| 1        | 20      | 3          | 3           | 3                |
| 1        | 20      | 4          | 3           | 3                |
| 1        | 24      | 5          | 5           | 4                |
| 1        | 30      | 6          | 6           | 5                |
| 1        | 30      | 7          | 6           | 5                |
| 1        | 30      | 8          | 6           | 5                |
| 1        | 40      | 9          | 9           | 6                |
| 1        | 40      | 10         | 9           | 6                |
| 2        | 10      | 1          | 1           | 1                |
| 2        | 10      | 2          | 1           | 1                |
| 2        | 10      | 3          | 1           | 1                |
| 2        | 20      | 4          | 4           | 2                |
| 2        | 20      | 5          | 4           | 2                |
| 2        | 20      | 6          | 4           | 2                |
| 2        | 30      | 7          | 7           | 3                |
| 2        | 30      | 8          | 7           | 3                |
| 2        | 30      | 9          | 7           | 3                |
| 2        | 60      | 10         | 10          | 4                |
+----------+---------+------------+-------------+------------------+

```

#### 聚合函数

**将指定范围的窗口聚合数据补充到当前行**，如：窗口内直到当前行，对指定列求和、求平均、求满足某条件的计数等， 常用函数如下：

  * avg(expr)，求平均
  * sum(expr)，求和
  * count(expr)，统计expr非null个数
  * ...


#### 跨行取数函数

跨行取数函数的作用在于可任意获取函数所在窗口内任意一行某个字段的值，如在**计算同比、环比指标或计算记录时间戳间隔时使用**跨行函数则会非常方便。 跨行取数函数使用时，
发生操作的行为当前行（current row）,常用的有以下四种：

* FIRST_VALUE(column)，在一次查询中取出当前窗口内第一行的某一字段的值；
* LAST_VALUE(column)，在一次查询中取出当前窗口内最后一行的某一字段的值；
* LAG(column,N,defaultValue)，在一次查询中取出从当前行之前N行的某一字段的值；
* LEAD(column,N,defaultValue)，在一次查询中取出从当前行之后N行的某一字段的值。

sql示例如下：
```sql
#假设有如下店铺月销售额表，求该店铺23年1月、2月及三月的同比、环比，其中与上年度数据对比称"同比"，与上月数据对比称"环比"
# 同比增长率计算公式：(当年值-上年值)/上年值x100%
# 环比增长率计算公式：(当月值-上月值)/上月值x100%
+----------------------+--------------------+---------------------+
|shop_id               | month              | amount              |
+----------------------+--------------------+---------------------+
| 1                    | 2022-01            | 150                 |
| 1                    | 2022-02            | 200                 |
| 1                    | 2022-03            | 180                 |
| 1                    | 2023-01            | 200                 |
| 1                    | 2023-02            | 300                 |
| 1                    | 2023-03            | 260                 |
+----------------------+--------------------+---------------------+

# 统计sql如下：
SELECT
	shop_id,
	`month`,
	amount,
	last_month_amount,
	last_year_month_amount,
	#计算环比,round保留2位小数
	round((amount / last_month_amount - 1)*100,2) AS month_on_month_ratio,
	#计算同比
	round((amount / last_year_month_amount - 1)*100,2) AS year_on_year_ratio 
FROM
	(
	SELECT
		shop_id,
		`month`,
		amount,
		#获取上月的金额（若没有上月的记录，则使用当前行的值）
		lag( amount, 1, amount ) over ( PARTITION BY shop_id ORDER BY `month` ) AS last_month_amount,
		#获取上一年同月份的金额（此处原表数据只有1月~3月的数据）
		lag( amount, 3, amount ) over ( PARTITION BY shop_id ORDER BY `month` ) AS last_year_month_amount 
	FROM
	shop_sale_m 
	) t1;
	
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
| shop_id  |  month   | amount  | last_month_amount  | last_year_month_amount  | month_on_month_ratio  | year_on_year_ratio  |
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
| 1        | 2022-01  | 150     | 150                | 150                     | 0.0                   | 0.0                 |
| 1        | 2022-02  | 200     | 150                | 200                     | 33.33                 | 0.0                 |
| 1        | 2022-03  | 180     | 200                | 180                     | -10.0                 | 0.0                 |
| 1        | 2023-01  | 200     | 180                | 150                     | 11.11                 | 33.33               |
| 1        | 2023-02  | 300     | 200                | 200                     | 50.0                  | 50.0                |
| 1        | 2023-03  | 260     | 300                | 180                     | -13.33                | 44.44               |
+----------+----------+---------+--------------------+-------------------------+-----------------------+---------------------+
```


### 窗口控制

窗口控制是指窗口函数在定义“窗口”（范围）来对数据进行计算的过程中可以使用rows between和range between语句来指定窗口的大小和位置。

#### rows between

用于指定窗口的范围，它以当前行为基准，根据自己的需求任意的控制窗口函数的范围。rows between的语法如下：

```sql
rows between [start] and [end]
```

start和end可以采用以下形式之一：

* unbounded preceding 当前行前面所有行
* unbounded following 当前行后面所有行
* current row 当前行
* n following  当前行后面n行
* n preceding  当前行前面n行

示例如下：
```sql
有如下表（无意义，仅测试）：
+---------------------+---------------------+
| number_order.group  | number_order.order  |
+---------------------+---------------------+
| 1                   | 1                   |
| 1                   | 2                   |
| 1                   | 3                   |
| 1                   | 4                   |
| 1                   | 5                   |
+---------------------+---------------------+

执行sql如下：

SELECT
     `order`,
     #计算当前行、前一行、后一行`order`之和
     sum( `order` ) over ( PARTITION BY `group` ORDER BY `order` rows BETWEEN 1 preceding AND 1 following ) `sum` 
FROM
     number_order;
 
 +--------+------+
| order  | sum  |
+--------+------+
| 1      | 3    |
| 2      | 6    |
| 3      | 9    |
| 4      | 12   |
| 5      | 9    |
+--------+------+
```


#### range between


range between可通过窗口内排序列值控制窗口大小，语法如下：
```dtd
RANGE BETWEEN n preceding AND m following
```

表示以当前值 current_value 为锚点， 从当前窗口中找出目标值符合 current_value - n  <= target_value <= current_value + m的行。 比如：range between 4 preceding AND 7 following，表示：如果当前值为10的话就取前后的值在6到17之间的数据。

示例如下：
```sql

源表同rows between中的number_order

SELECT
     `order`,
     sum( `order` ) over ( PARTITION BY `group` ORDER BY `order` range BETWEEN 2 preceding AND 2 following ) `sum` 
FROM
     number_order;

+--------+------+
| order  | sum  |
+--------+------+
| 1      | 6    |    #   -1 <= order <= 3  =>   1,2,3
| 2      | 10   |    #    0 <= order <= 4  =>   1,2,3,4
| 3      | 15   |    #    1 <= order <= 5  =>   1,2,3,4,5
| 4      | 14   |    #    2 <= order <= 6  =>   2,3,4,5
| 5      | 12   |    #    3 <= order <= 7  =>   3,4,5
+--------+------+

```

# 关联运算

JOIN子句用于把来自两个或多个表的行按照指定的条件关联结合起来，常用的关联方式有：
* 有指定ON条件：
  * INNER JOIN：左表与右表均存在满足ON条件的记录则返回关联后的记录
  * OUTER JOIN
    * LEFT JOIN：即使右表中没有匹配的行，也从左表返回对应的行，右边字段补null
    * RIGHT JOIN：即使左表中没有匹配的行，也从右表返回对应的行，左表字段补null
    * FULL JOIN：左右两边只要其中一个表中存在匹配，则返回行，剩余一边字段补null
* 未指定ON条件
  * [CROSS] JOIN：笛卡尔积，即将左表的每一行与右表的每一行合并（慎用，结果集将非常大，若左表与右表均有1万条记录，那cross join将产生 10000 * 10000 = 1亿条记录的结果集）。


# 常见问题

## TopN

使用窗口函数排序后过滤即可。


## 连续发生

解决思路：

* 1、使用where过滤出符合条件的记录 ，并按业务维度分区及按业务发生序号（记录序号）排序打行号
* 2、计算 记录序号 - 行号 的值，得到的差值会有规律：因行号是连续的，如果记录序号连续， 则差值保持恒定
* 3、按差值分组统计count，过滤count值符合条件的记录

示例sql：
```sql
有如下用户登录记录表，求连续登录3天的用户
+-----------------+------------------------+
| user_login.uid  | user_login.login_date  |
+-----------------+------------------------+
| 1               | 2023-10-01             |
| 1               | 2023-10-03             |
| 1               | 2023-10-04             |
| 1               | 2023-10-05             |
| 1               | 2023-10-07             |
| 2               | 2023-10-01             |
| 2               | 2023-10-03             |
| 2               | 2023-10-04             |
| 2               | 2023-10-07             |
+-----------------+------------------------+


# 1、过滤出符合条件的记录 ，并按业务维度分区及按业务发生序号（记录序号）排序打行号
# 此例中无需过滤，仅发生登录行为才会有记录

SELECT
	uid,
	login_date,
	row_number() over ( PARTITION BY uid ORDER BY login_date ) AS rn 
FROM
	user_login;

+------+-------------+-----+
| uid  | login_date  | rn  |
+------+-------------+-----+
| 1    | 2023-10-01  | 1   |
| 1    | 2023-10-03  | 2   |
| 1    | 2023-10-04  | 3   |
| 1    | 2023-10-05  | 4   |
| 1    | 2023-10-07  | 5   |
| 2    | 2023-10-01  | 1   |
| 2    | 2023-10-03  | 2   |
| 2    | 2023-10-04  | 3   |
| 2    | 2023-10-07  | 4   |
+------+-------------+-----+

# 2、计算 记录序号 - 行号 的值

SELECT
	uid,
	login_date,
	# 记录序号 - 行号
	date_sub(login_date, row_number() over ( PARTITION BY uid ORDER BY login_date )) AS diff 
FROM
	user_login;

+------+-------------+-------------+
| uid  | login_date  |    diff     |
+------+-------------+-------------+
| 1    | 2023-10-01  | 2023-09-30  |
| 1    | 2023-10-03  | 2023-10-01  |
| 1    | 2023-10-04  | 2023-10-01  |
| 1    | 2023-10-05  | 2023-10-01  |
| 1    | 2023-10-07  | 2023-10-02  |
| 2    | 2023-10-01  | 2023-09-30  |
| 2    | 2023-10-03  | 2023-10-01  |
| 2    | 2023-10-04  | 2023-10-01  |
| 2    | 2023-10-07  | 2023-10-03  |
+------+-------------+-------------+

# 3、按差值分组统计count，过滤count值符合条件的记录

SELECT
	uid,
	diff,
	count(1) AS times,
	min(login_date) AS startDate,
	max(login_date) AS endDate
FROM
	( 
		SELECT
			uid,
			login_date,
			date_sub(login_date, row_number() over ( PARTITION BY uid ORDER BY login_date )) AS diff 
		FROM
			user_login
	) t1 
GROUP BY
	uid,
	diff
HAVING
	count(1) > 2;

# 用户1在10-03~10-05期间连续登录3次
+------+-------------+--------+-------------+-------------+
| uid  |    diff     | times  |  startdate  |   enddate   |
+------+-------------+--------+-------------+-------------+
| 1    | 2023-10-01  | 3      | 2023-10-03  | 2023-10-05  |
+------+-------------+--------+-------------+-------------+
```

## 拉链表求持续周期

拉链表是针对数据仓库设计中表存储数据的方式而定义的，顾名思义，所谓拉链，就是记录历史。记录一个事物从开始，一直到当前状态的所有变化的信息。主要用于解决缓慢变化维，简称SCD（Slowly Changing Dimensions）问题，即**数据有一定规模**，但数据随时间缓慢变化（单位时间内，如一天内数据发生更新的比例不高），使用拉链表既可以
保存维度的历史快照数据，又可以防止数据冗余太多，浪费空间。

持续周期问题解决思路：

* 1、 做分组标记，标记为int类型，从0开始，若目标列值没有发生变化，标记值保持，若发生变化，则自增+1
  * 1.1、为每行数据打标，指定列的数据发生变化则打标1，否则0
  * 1.2、求打标数据至当前行的累加值（sum）
* 2、按分组标记分组，获取持续时间段
  * 2.1、按分组标记分组，取每组最小创建时间作为起始时间
  * 2.2、使用上一步的结果集，取下一行的起始时间 -1 ，作为本行的结束时间


```sql
有商户费率表（只给出了fee字段）如下，记录了该商户所有费率变动日期及对应的费率，求每次费率的持续时间：
+-------------------+-------------------+------------------+
| merchant_fee.mid  | merchant_fee.fee  | merchant_fee.dt  |
+-------------------+-------------------+------------------+
| 100               | 0.10              | 2023-09-02       |
| 100               | 0.10              | 2023-10-02       |
| 100               | 0.20              | 2023-10-05       |
| 100               | 0.20              | 2023-10-06       |
| 100               | 0.30              | 2023-10-07       |
| 100               | 0.10              | 2023-10-09       |
| 100               | 0.10              | 2023-10-10       |
| 100               | 0.10              | 2023-10-14       |
| 100               | 0.10              | 2023-10-18       |
+-------------------+-------------------+------------------+

# 1.1、为每行数据打标，指定列的数据发生变化则打标1，否则0

SELECT
	mid,
	fee,
	dt,
	pre_fee,
	#上一行fee字段不为null 且 本行fee不等于 上一行的fee, 则发生了变化 打标1 否则 0
	IF(pre_fee IS NOT NULL AND fee != pre_fee,1,0) AS mark 
FROM
( 
	SELECT
		mid,
		fee,
		dt,
		#将上一行的fee字段的值取到本行
		lag( fee, 1, NULL ) over ( PARTITION BY mid ORDER BY dt ) AS pre_fee 
	FROM
		merchant_fee
) o;


+------+-------+-------------+----------+-------+
| mid  |  fee  |     dt      | pre_fee  | mark  |
+------+-------+-------------+----------+-------+
| 100  | 0.10  | 2023-09-02  | NULL     | 0     |
| 100  | 0.10  | 2023-10-02  | 0.10     | 0     |
| 100  | 0.20  | 2023-10-05  | 0.10     | 1     |
| 100  | 0.20  | 2023-10-06  | 0.20     | 0     |
| 100  | 0.30  | 2023-10-07  | 0.20     | 1     |
| 100  | 0.10  | 2023-10-09  | 0.30     | 1     |
| 100  | 0.10  | 2023-10-10  | 0.10     | 0     |
| 100  | 0.10  | 2023-10-14  | 0.10     | 0     |
| 100  | 0.10  | 2023-10-18  | 0.10     | 0     |
+------+-------+-------------+----------+-------+


#1.2、求打标数据至当前行的累加值（sum）

SELECT 
	mid,
	fee,
	dt,
	sum(mark) over (partition by mid ORDER BY dt) as times
# temp表为上一步结果集
FROM temp 

# 可以看到，若fee发生变化，则累加值也发生了变化
+------+-------+-------------+--------+
| mid  |  fee  |     dt      | times  |
+------+-------+-------------+--------+
| 100  | 0.10  | 2023-09-02  | 0      |
| 100  | 0.10  | 2023-10-02  | 0      |
| 100  | 0.20  | 2023-10-05  | 1      |
| 100  | 0.20  | 2023-10-06  | 1      |
| 100  | 0.30  | 2023-10-07  | 2      |
| 100  | 0.10  | 2023-10-09  | 3      |
| 100  | 0.10  | 2023-10-10  | 3      |
| 100  | 0.10  | 2023-10-14  | 3      |
| 100  | 0.10  | 2023-10-18  | 3      |
+------+-------+-------------+--------+


#2.1 按照标记字段分组，并取最小时间戳
SELECT 
	mid,
	fee,
	times,
	min(dt) AS start_date
FROM
(
    SELECT 
        mid,
        fee,
        dt,
        sum(mark) over (partition by mid ORDER BY dt) as times
    FROM temp 
) t1
GROUP BY 
    mid,
	fee,
	times;
	
+------+-------+--------+-------------+
| mid  |  fee  | times  | start_date  |
+------+-------+--------+-------------+
| 100  | 0.10  | 0      | 2023-09-02  |
| 100  | 0.10  | 3      | 2023-10-09  |
| 100  | 0.20  | 1      | 2023-10-05  |
| 100  | 0.30  | 2      | 2023-10-07  |
+------+-------+--------+-------------+


#2.2、lead()行数取下一行的start_date -1,作为本行的结束时间

SELECT
	mid,
	fee,
	start_date,
	#取下一行的start_date，没有则默认最大值'9999-99-99' ，date_sub 减一
	date_sub( lead( start_date, 1, '9999-99-99' ) over ( PARTITION BY mid ORDER BY start_date ), 1 ) AS end_date 
FROM
(
   SELECT 
        mid,
        fee,
        times,
        min(dt) AS start_date
    FROM
    (
        SELECT 
            mid,
            fee,
            dt,
            sum(mark) over (partition by mid ORDER BY dt) as times
        FROM temp 
    ) t1
    GROUP BY 
        mid,
        fee,
        times
)t2;

+------+-------+-------------+-------------+
| mid  |  fee  | start_date  |  end_date   |
+------+-------+-------------+-------------+
| 100  | 0.10  | 2023-09-02  | 2023-10-04  |
| 100  | 0.20  | 2023-10-05  | 2023-10-06  |
| 100  | 0.30  | 2023-10-07  | 2023-10-08  |
| 100  | 0.10  | 2023-10-09  | NULL        |
+------+-------+-------------+-------------+
```



