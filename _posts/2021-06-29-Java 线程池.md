---
layout: post
title:  "Java 线程池"
date:   2021-06-29 19:14:51
categories: JDK
---

绝大多数情况下，Java的线程模式都是1:1模型，即采用内核线程实现，且**一个线程是不能重复启动的**，过多线程带来开销不容忽视，如创建、销毁线程
的开销、调度线程的开销(频繁的用户态内核态切换)，同时也降低了计算机的整体性能。

线程池(Thread Pool)是一种基于**池化思想**管理线程的工具，解决的核心问题就是**资源管理问题**。在并发环境下，系统不能够确定在任意时刻中，
有多少任务需要执行，有多少资源需要投入。通过线程池持有一定量线程，当应用需要使用线程执行任务时，将任务提交给线程池，由线程池内的某一线程执行，
避免用户随意创建线程。

#### 概览

Java标准类库提供了几种基础实现，比如ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。**ScheduledThreadPoolExecutor**
是ThreadPoolExecutor的扩展，主要是**增加了调度逻辑**，**而ForkJoinPool则是为ForkJoinTask定制的线程池**。UML类图如下：

![threadPoolUML.png](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/threadpool.png)<br />

顶层接口Executor内只有一个方法，**void execute(Runnable command)**，其展现了一种思想：**将任务提交和任务执行解耦**。用户无需关注任何创建
线程，如何调度线程来执行任务，用户只需提供Runnable对象，由Executor框架完成线程的调配和任务的执行部分。

ExecutorService中增加了一些能力：

* 扩充执行任务的能力，增加了可以为一个或一批异步任务生成Future的方法；
```
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);

<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
...
<T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
...
```

* 提供了管控线程池的方法
```
void shutdown();  //执行完已提交的任务后关闭，期间不再接收任务提交
List<Runnable> shutdownNow();  //尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; //阻塞当前线程直至超时会线程池关闭
```

#### ThreadPoolExecutor

ThreadPoolExecutor内部实际上构建了一个**生产者消费者模型，将线程和任务两者解耦**，具体实现可分为2部分：

##### 线程池的生命周期

JDK中并没有使用单独的字段维护线程池运行状态，而是使用**ctl**字段同时维护了运行状态(runState)和线程数量(workerCount)。高3位保存runState，
低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，**不必为了维护两者的一致，而占用锁资源**。
```
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// Packing and unpacking ctl
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

线程池的运行状态在源码中共定义了5中，分别为：

| runState   | desc                                                                                    |
|------------|-----------------------------------------------------------------------------------------|
| RUNNING    | 可接受新提交的任务,阻塞队列中的任务也可正常执行                                                |
| SHUTDOWN   | 不再接受新的任务，但阻塞队列中的任务可正常执行                                                 |
| STOP       | 不再接受新的任务，阻塞队列中的任务也不会被执行，且会尝试中断(interrupt)正常处理中的任务              |
| TIDYING    | 所有任务已终止，workCount=0                                                               |
| TERMINATED | terminated()执行完后进入该状态                                                             |

生命周期的转换过程为：

![threadPoolStatus.png](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/threadpoolState.png)<br />


**shutdown()和shutdownNow()对比**：

* 线程池状态变更不同。
```
shutdown->advanceRunState(SHUTDOWN); 
shutdownNow->advanceRunState(STOP);
```
* shutdown只**中断空闲工作线程,且会等待阻塞队列中的任务执行完**，shutdownNow会**中断所有工作线程**;
```
shutdown->interruptIdleWorkers(); 
shutdownNow->interruptWorkers();
```
* shutdown没有返回值，shutdownNow会返回阻塞队列中尚未执行的任务；
```
public void shutdown() 
public List<Runnable> shutdownNow()
```

##### 任务调度执行

ThreadPoolExecutor中的**任务调度都在execute()方法中完成**，详情如下：
```
int c = ctl.get();
if (workerCountOf(c) < corePoolSize) {     //workerCount< corePoolSize，创建并启动一个worker执行任务
    if (addWorker(command, true))  /
        return;
    c = ctl.get();
}
if (isRunning(c) && workQueue.offer(command)) {  //workerCount大于corePoolSize，阻塞队列未满，将任务添加到阻塞队列
    int recheck = ctl.get();
    if (! isRunning(recheck) && remove(command))
        reject(command);
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
else if (!addWorker(command, false))  //workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满
                                     //创建非核心worker执行任务
    reject(command);  //workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满，拒绝任务，根据拒绝策略处理，默认抛出异常。
```

实现任务调度的核心有3部分：

* 阻塞队列
    
    阻塞队列**是线程池能够管理任务的核心部分**。通过阻塞队列及生产者消费者模式实现**任务和线程的解耦**，生产者向队列中添加任务，消费者(Worker)
    从队列中获取任务执行。
    
    JDK中提供的BlockingQueueUML如下：
    
    ![BlockingQueueUML.png](https://raw.githubusercontent.com/GuanN1ng/GuanN1ng.github.io/main/_posts/image/blockqueue.png)<br />
    
    对比如下：
    
    | name                  | desc                                                                                         |
    |-----------------------|----------------------------------------------------------------------------------------------|
    | ArrayBlockingQueue    | 由**数组**实现的有界队列，按照FIFO原则排序，支持公平锁和非公平锁                             |
    | LinkedBlockingQueue   | 由**单链表**实现的有界队列，按照FIFO原则排序，**默认容量为Integer.MAX_VALUE**                |
    | PriorityBlockingQueue | 由**数组实现支持优先级的无届队列(offer方法中数组动态扩容)**，可自定义实现**compareTo()方法** |
    | DelayQueue            | 内部持有一个**PriorityQueue**，                                                              |
    | SynchronousQueue      |                                                                                              |
    | LinkedTransferQueue   |                                                                                              |
    | LinkedBlockingDeque   | 由**双向链表**实现的有界队列，多线程并发时(工作窃取法)，可以将锁的竞争做多降到1/2            |


* Worker线程

* 拒绝策略

    任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要
    拒绝掉该任务，采取任务拒绝策略，保护线程池。
    
    拒绝策略必须实现**RejectedExecutionHandler**接口，用户可以自定义实现，JDK中提供了4中策略供用户使用：
    
    | name                                   | desc                                                                                                     |
    |----------------------------------------|----------------------------------------------------------------------------------------------------------|
    | ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出RejectedExecutionException异常，默认拒绝策略。建议使用，**用户可通过异常感知程序运行状态** |
    | ThreadPoolExecutor.DiscardPolicy       | 丢弃任务，但**不抛出异常**                                                                               |
    | ThreadPoolExecutor.CallerRunsPolicy    | 由提交任务的线程处理该任务。可确保所有任务都执行完毕                                                     |
    | ThreadPoolExecutor.DiscardOldestPolicy | **丢弃阻塞队列最前面的任务**，并再次提交                                                                 |
    

线程池优势：

* 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
* 提高响应速度：任务到达时，无需等待线程创建即可立即执行。
* 提高线程的可管理性：使用线程池可以对应用内的线程进行统一的分配、调优和监控。
* 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。