---
layout: post 
title:  Kafka 时间轮与延时任务 
date:   2022-01-03 18:28:46 
categories: Kafka
---

# TimingWheel

Kafka中存在大量的延时操作，比如延时生产、延时拉取和延时删除等。Kafka并没有使用JDK自带的Timer或DelayQueue来实现延时的功能，而是基于时间轮的概念自定义实现了一个
用千延时功能的定时器(SystemTimer)。JDK中Timer和DelayQueue(二者的任务存储均使用数组实现的基于平衡二叉树的优先级队列)的插入和删除操作的平均时间复杂度为O(logn)并不能满足Kafka的高性能要求，
而基于时间轮可以将插入和删除操作的时间复杂度都降为0(1)。


TimingWheel类定义如下：

```
private[timer] class TimingWheel(tickMs: Long,  //时间轮时间格跨度  
                                 wheelSize: Int,  //时间轮时间格数，即单层时间轮buckets数量，固定20
                                 startMs: Long,  // 时间轮对象被创建时的起始时间戳
                                 taskCounter: AtomicInteger, //本层时间轮上的总定时任务数
                                 queue: DelayQueue[TimerTaskList] //将所有bucket按照延迟时间排序的延迟队列
                                 ) {
  //时间轮的总时间跨度
  private[this] val interval = tickMs * wheelSize 
  //时间轮数组，
  private[this] val buckets = Array.tabulate[TimerTaskList](wheelSize) { _ => new TimerTaskList(taskCounter) }
  //当前时间轮所处的时间。小于当前时间的最大时间跨度的整数倍
  private[this] var currentTime = startMs - (startMs % tickMs) // rounding down to multiple of tickMs

  // volatile JVM可见性
  //上层时间轮
  @volatile private[this] var overflowWheel: TimingWheel = null
  
  ... //other code
}
```

TimingWheel使用**数组实现一个环形列表，即buckets，长度wheelSize为20**，数组中每一格都代表**一个单位的时间跨度，值为tickMs**，则时间轮的总时间跨度为`interval=wheelSize*tickMs`，下标为0的数组元素所对应的时间为**本时间轮的起始时间startMs**，即时间轮被创建的
时间，currentTime表示小于当前时间(时间戳)的最大时间跨度的整数倍，假设当前时间戳为123毫秒，时间轮每格跨度为20ms，那么currentTime就是最大的小于123且是20整数倍的数字，即120ms，currentTime将整个时间轮划分为到期部分和未到期部分，**currentTime指向的数组元素即为当前需执行的到期任务**， 数组中的元素类型为TimerTaskList，定义如下：

```
private[timer] class TimerTaskList(taskCounter: AtomicInteger) extends Delayed {
  // TimerTaskList forms a doubly linked cyclic list using a dummy root entry
  //root节点为哑结点，简化双向链表的边界处理条件
  private[this] val root = new TimerTaskEntry(null, -1)
  root.next = root
  root.prev = root
  //链表中任务到期时间
  private[this] val expiration = new AtomicLong(-1L)
  ...// other code
}  
```

TimerTaskList对一个双向环形链表，该链表的第一个节点为哑结点，用于插入或删除时简化边界条件的处理。节点类型为TimerTaskEntry对象，用于封装延时任务。时间轮示意图如下：

![TimingWheel](https://raw.githubusercontent.com/GuanN1ng/diagrams/main/com.guann1n9.diagrams/kakfa/Kafka%20TimeWheel.png){:height="80%" width="80%"}


## 延时任务

同一时间到期的延时任务被组织为TimerTaskList双向循环链表，每个TimerTaskEntry节点都表示一个延时任务，TimerTaskEntry的类定义如下：

```
private[timer] class TimerTaskEntry(val timerTask: TimerTask, //延时任务
                                    val expirationMs: Long //到期时间 delayMs + Time.SYSTEM.hiResClockMs
                                    ) extends Ordered[TimerTaskEntry] {

  @volatile
  var list: TimerTaskList = null //所在链表 方便操作
  var next: TimerTaskEntry = null //后驱指针
  var prev: TimerTaskEntry = null //前驱指针
  //传递引自身引用给TimerTask
  if (timerTask != null) timerTask.setTimerTaskEntry(this) 
  ...
```

每个TimerTaskEntry不仅持有前后相邻的节点引用，还持有所在双向链表TimerTaskList的引用，具体的延时任务类型为TimerTask，TimeTask继承及Runnable接口，delayMs字段表示这个定时任务的延时时间，TimerTaskEntry
初始化时，也会调setTimerTaskEntry()方法用将自身的引用设置给TimerTask。TimerTask类定义如下：

```
trait TimerTask extends Runnable {
  val delayMs: Long // 延时时间
  private[this] var timerTaskEntry: TimerTaskEntry = null
  
    private[timer] def setTimerTaskEntry(entry: TimerTaskEntry): Unit = {
    synchronized {
      // if this timerTask is already held by an existing timer task entry,
      // we will remove such an entry first.
      if (timerTaskEntry != null && timerTaskEntry != entry)
        //该TimerTask已被其他TimerTaskEntry对象持有，移除旧的TimerTaskEntry
        timerTaskEntry.remove()

      timerTaskEntry = entry
    }
  }
```

若TimerTaskEntry调用setTimerTaskEntry()方法传递其引用时，TimerTask已被其他imerTaskEntry对象持有，则调用TimerTaskEntry#remove()方法，将旧的TimerTaskEntry
对象从TimerTaskList中移除。


## 延时任务添加

时间轮的延时任务添加方法TimingWheel#add()源码如下：


```
  def add(timerTaskEntry: TimerTaskEntry): Boolean = {
    //任务到期时间 delayMs + Time.SYSTEM.hiResClockMs
    val expiration = timerTaskEntry.expirationMs

    if (timerTaskEntry.cancelled) {
      // 任务已取消
      false
    } else if (expiration < currentTime + tickMs) {
      // 任务已超时，无需添加  到期时间小于 当前时间+一个单位时间
      false
    } else if (expiration < currentTime + interval) {
      // 当前时间轮的时间跨度满足延时任务的延时时间，按照延迟时间获取时间轮位置，并放入
      val virtualId = expiration / tickMs
      val bucket = buckets((virtualId % wheelSize.toLong).toInt)
      bucket.add(timerTaskEntry)

      //为bucket设置过期时间
      if (bucket.setExpiration(virtualId * tickMs)) {
        //bucket过期时间更新，将bucket放入延时队列中
        queue.offer(bucket)
      }
      true
    } else {
      //延迟时间超过当前时间轮跨度，判断是否存在上层时间轮，并添加
      if (overflowWheel == null) addOverflowWheel()
      overflowWheel.add(timerTaskEntry)
    }
  }
  
  //bucket到期时间设置，相同则不再设置
  def setExpiration(expirationMs: Long): Boolean = {
    expiration.getAndSet(expirationMs) != expirationMs
  }
```

过程如下：

* 1、判断延时任务是否有效，是否已被取消或已超时，若满足则返回false，取消添加；


* 2、判断当前时间轮的时间跨度是否满足延时任务的到期时间：
  * 2.1、若满足，使用`(expiration / tickMs) % wheelSize`计算buckets数组下标，添加到对应的TimerTaskList列表中，并尝试更新TimerTaskList过期时间，若更新成功(首次添加任务，或已被执行过，当前进行复用)，
  则将TimerTaskList添加到延迟队列中(Java DelayQueue)。
  * 2.2、任务的延迟时间超过时间轮的跨度，判断是否已创建上层时间轮，若未创建，则调用addOverflowWheel()方法创建，否则调用上层时间轮的add()方法完成任务添加。


### 多层时间轮

为**避免无限扩充时间轮大小(wheelSize)**，Kafka引入了层级时间轮的概念，上一步添加延时任务时，若任务的到期时间超过当前时间轮所能表示的时间跨度，则会创建**上层时间轮overflowWheel**来存储延时任务，创建方法源码如下：

```
  private[this] def addOverflowWheel(): Unit = {
    synchronized {
      if (overflowWheel == null) {
        overflowWheel = new TimingWheel(
          tickMs = interval, //上层时间轮的时间单位是下层时间轮的时间跨度
          wheelSize = wheelSize, //同样是20
          startMs = currentTime, //当前时间即为起始时间
          taskCounter = taskCounter, //同一个任务计数器
          queue //同一个延迟队列
        )
      }
    }
  }
```

上层时间轮的单位时间跨度tickMs是下层时间轮的总时间跨度，但不管时间轮最终有几层，时间轮的wheelSize始终为20。 此时：

* 第一层时间轮的tickMs=1ms，wheelSize=20、interval=20ms。
* 第二层的时间轮的tickMs为第一层时间轮的interval,即20ms，wheelSize仍为20，interval=20*20=400ms;
* 若继续扩展到第三层，此时第三层时间轮的tickMs=400ms，wheelSize=20、interval=400*20=8000ms，依次类推。

则第一层时间轮负责存储延时时间为[1ms,20ms)的任务，第二层负责存储延时时间为[20ms,400ms)的任务，第三层则负责存储延时时间为[400ms,8000ms)的任务，示意图如下：

![多层时间轮](https://raw.githubusercontent.com/GuanN1ng/diagrams/main/com.guann1n9.diagrams/kakfa/kafka%20overflowWheel.png){:height="80%" width="80%"}











